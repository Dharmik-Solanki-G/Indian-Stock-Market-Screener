#!/usr/bin/env python3
"""
Indian Stock Market Screener App
Single-file Python application for screening Indian stocks using technical indicators
"""

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import json
import os
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import warnings
warnings.filterwarnings('ignore')

# MOVED THE 'ta' IMPORT AND CHECK INTO main()

# Configuration - Use absolute paths
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
CACHE_DIR = os.path.join(BASE_DIR, "ohlcv_cache")
STRATEGIES_DIR = os.path.join(BASE_DIR, "strategies")
DATA_DIR = os.path.join(BASE_DIR, "data")
STOCKS_FILE = os.path.join(DATA_DIR, "stocks.csv")

# Create directories with error handling
def create_directories():
    """Create necessary directories with proper error handling"""
    directories = [CACHE_DIR, STRATEGIES_DIR, DATA_DIR]
    
    for directory in directories:
        try:
            os.makedirs(directory, exist_ok=True)
            # Test write permission
            test_file = os.path.join(directory, "test_write.tmp")
            with open(test_file, 'w') as f:
                f.write("test")
            os.remove(test_file)
        except PermissionError:
            st.error(f"Permission denied: Cannot create or write to directory {directory}")
            st.error("Please run the application from a directory where you have write permissions.")
            st.stop()
        except Exception as e:
            st.error(f"Error creating directory {directory}: {str(e)}")
            st.error("Please check your file system permissions.")
            st.stop()

# ==============================================================================
# UPDATED StockScreener CLASS WITH DYNAMIC ENGINE
# ==============================================================================
class StockScreener:
    def __init__(self):
        self.stocks_df = self.load_stock_list()
        self.strategies = self.load_strategies()

    def load_stock_list(self) -> pd.DataFrame:
        """Load NSE stock list, create if doesn't exist"""
        if os.path.exists(STOCKS_FILE):
            # Check if file is older than 7 days, refresh if needed
            file_age = time.time() - os.path.getmtime(STOCKS_FILE)
            if file_age < 7 * 24 * 3600:  # 7 days
                try:
                    df = pd.read_csv(STOCKS_FILE)
                    # Ensure we have both symbol and name columns
                    if 'symbol' in df.columns and 'name' in df.columns:
                        return df
                except Exception as e:
                    print(f"Error reading cached stocks file: {e}")
        
        # Fetch complete NSE stock list
        st.info("Fetching complete NSE stock list... This may take a moment.")
        
        all_nse_stocks = [
            "RELIANCE.NS", "TCS.NS", "HDFCBANK.NS", "BHARTIARTL.NS", "ICICIBANK.NS", "INFY.NS", "SBIN.NS", "LICI.NS", "HINDUNILVR.NS", "ITC.NS", "LT.NS", "HCLTECH.NS", "BAJFINANCE.NS", "SUNPHARMA.NS", "NTPC.NS",
            "MARUTI.NS", "AXISBANK.NS", "ONGC.NS", "M&M.NS", "KOTAKBANK.NS", "TATAMOTORS.NS", "ADANIENT.NS", "ULTRACEMCO.NS", "POWERGRID.NS", "HAL.NS", "TITAN.NS", "ADANIPORTS.NS", "DMART.NS", "COALINDIA.NS", "WIPRO.NS",
            "BAJAJ-AUTO.NS", "ASIANPAINT.NS", "BAJAJFINSV.NS", "ADANIGREEN.NS", "SIEMENS.NS", "ADANIPOWER.NS", "TRENT.NS", "NESTLEIND.NS", "JSWSTEEL.NS", "ZOMATO.NS", "HINDZINC.NS", "IOC.NS", "BEL.NS", "IRFC.NS", "JIOFIN.NS",
            "DLF.NS", "VBL.NS", "TATASTEEL.NS", "VEDL.NS", "LTIM.NS", "GRASIM.NS", "INDIGO.NS", "SBILIFE.NS", "PFC.NS", "ABB.NS", "TECHM.NS", "PIDILITIND.NS", "HINDALCO.NS", "AMBUJACEM.NS", "HYUNDAI.NS",
            "HDFCLIFE.NS", "RECLTD.NS", "DIVISLAB.NS", "GAIL.NS", "BPCL.NS", "TATAPOWER.NS", "GODREJCP.NS", "BRITANNIA.NS", "EICHERMOT.NS", "MOTHERSON.NS", "LODHA.NS", "BANKBARODA.NS", "CIPLA.NS", "JSWENERGY.NS", "TVSMOTOR.NS",
            "PNB.NS", "SHRIRAMFIN.NS", "CHOLAFIN.NS", "BAJAJHFL.NS", "SWIGGY.NS", "BAJAJHLDNG.NS", "NTPCGREEN.NS", "HAVELLS.NS", "ADANIENSOL.NS", "CGPOWER.NS", "TORNTPHARM.NS", "DRREDDY.NS", "IOB.NS", "ZYDUSLIFE.NS", "TATACONSUM.NS",
            "UNITDSPR.NS", "RVNL.NS", "HEROMOTOCO.NS", "DABUR.NS", "ICICIPRULI.NS", "BOSCHLTD.NS", "POLYCAB.NS", "INDUSTOWER.NS", "CUMMINSIND.NS", "NAUKRI.NS", "INDHOTEL.NS", "APOLLOHOSP.NS", "MANKIND.NS", "OFSS.NS", "INDUSINDBK.NS",
            "ICICIGI.NS", "JINDALSTEL.NS", "SOLARINDS.NS", "CANBK.NS", "LUPIN.NS", "MAXHEALTH.NS", "SUZLON.NS", "BHEL.NS", "UNIONBANK.NS", "SHREECEM.NS", "IDBI.NS", "NHPC.NS", "HDFCAMC.NS", "MAZDOCK.NS", "OIL.NS",
            "COLPAL.NS", "ATGL.NS", "DIXON.NS", "MARICO.NS", "PERSISTENT.NS", "HINDPETRO.NS", "WAAREEENER.NS", "GODREJPROP.NS", "TORNTPOWER.NS", "GMRAIRPORT.NS", "AUROPHARMA.NS", "IDEA.NS", "POLICYBZR.NS", "TIINDIA.NS", "MUTHOOTFIN.NS",
            "INDIANB.NS", "PRESTIGE.NS", "IRCTC.NS", "SRF.NS", "YESBANK.NS", "GICRE.NS", "BHARATFORG.NS", "OBEROIRLTY.NS", "SBICARD.NS", "ASHOKLEY.NS", "ALKEM.NS", "JSWINFRA.NS", "KALYANKJIL.NS", "NMDC.NS", "BHARTIHEXA.NS",
            "PIIND.NS", "SUPREMEIND.NS", "LINDEINDIA.NS", "PATANJALI.NS", "BERGEPAINT.NS", "FACT.NS", "PHOENIXLTD.NS", "IREDA.NS", "JSL.NS", "UNOMINDA.NS", "SCHAEFFLER.NS", "UCOBANK.NS", "THERMAX.NS", "BALKRISIND.NS", "VOLTAS.NS",
            "MRF.NS", "MPHASIS.NS", "CONCOR.NS", "ABCAPITAL.NS", "LTTS.NS", "POWERINDIA.NS", "SAIL.NS", "TATACOMM.NS", "NYKAA.NS", "UBL.NS", "PGHH.NS", "ASTRAL.NS", "IDFCFIRSTB.NS", "PETRONET.NS", "BANKINDIA.NS",
            "HUDCO.NS", "PREMIERENE.NS", "CENTRALBK.NS", "BSE.NS", "SUNDARMFIN.NS", "COROMANDEL.NS", "SJVN.NS", "COCHINSHIP.NS", "FEDERALBNK.NS", "PAGEIND.NS", "COFORGE.NS", "AUBANK.NS", "VMM.NS", "MOTILALOFS.NS", "LLOYDSME.NS",
            "BDL.NS", "KPITTECH.NS", "TATAELXSI.NS", "GVT&D.NS", "GLENMARK.NS", "GLAXO.NS", "ACC.NS", "FORTIS.NS", "PAYTM.NS", "AWL.NS", "NAM-INDIA.NS", "HONAUT.NS", "OLAELEC.NS", "FLUOROCHEM.NS", "MAHABANK.NS",
            "BIOCON.NS", "UPL.NS", "ESCORTS.NS", "JUBLFOOD.NS", "APLAPOLLO.NS", "EXIDEIND.NS", "SONACOMS.NS", "TATATECH.NS", "LTF.NS", "GUJGASLTD.NS", "360ONE.NS", "3MINDIA.NS", "MFSL.NS", "KEI.NS", "AIAENG.NS",
            "DEEPAKNTR.NS", "NATIONALUM.NS", "BLUESTARCO.NS", "NIACL.NS", "PSB.NS", "APARINDS.NS", "AJANTPHARM.NS", "IPCALAB.NS", "LICHSGFIN.NS", "NLCINDIA.NS", "M&MFIN.NS", "IRB.NS", "CRISIL.NS", "GODREJIND.NS", "DALBHARAT.NS",
            "SYNGENE.NS", "ENDURANCE.NS", "METROBRAND.NS", "JKCEMENT.NS", "KAYNES.NS", "TATAINVEST.NS", "IKS.NS", "IGL.NS", "ABFRL.NS", "APOLLOTYRE.NS", "FIRSTCRY.NS", "STARHEALTH.NS", "GODIGIT.NS", "MRPL.NS", "EMAMILTD.NS",
            "KPRMILL.NS", "CHOLAHLDNG.NS", "SUNTV.NS", "CDSL.NS", "MANYAVAR.NS", "BANDHANBNK.NS", "GLAND.NS", "GODFRYPHLP.NS", "MEDANTA.NS", "MSUMI.NS", "BRIGADE.NS", "NBCC.NS", "HINDCOPPER.NS", "POONAWALLA.NS", "PPLPHARMA.NS",
            "SUVENPHAR.NS", "JBCHEPHARM.NS", "DELHIVERY.NS", "GILLETTE.NS", "CARBORUNIV.NS", "ABREL.NS", "BASF.NS", "ZFCVINDIA.NS", "AEGISLOG.NS", "ITI.NS", "RADICO.NS", "SUNDRMFAST.NS", "TIMKEN.NS", "TATACHEM.NS", "CROMPTON.NS",
            "ISEC.NS", "JYOTICNC.NS", "SUMICHEM.NS", "LALPATHLAB.NS", "INOXWIND.NS", "HSCL.NS", "LAURUSLABS.NS", "EMCURE.NS", "TVSHLTD.NS", "GRINDWELL.NS", "AIIL.NS", "WHIRLPOOL.NS", "SKFINDIA.NS", "ARE&M.NS", "HATSUN.NS",
            "NH.NS", "NATCOPHARM.NS", "KEC.NS", "RATNAMANI.NS", "PFIZER.NS", "EIHOTEL.NS", "CESC.NS", "KIOCL.NS", "PEL.NS", "POLYMED.NS", "ANGELONE.NS", "PNBHOUSING.NS", "IGIL.NS", "CASTROLIND.NS", "KANSAINER.NS",
            "NUVAMA.NS", "IRCON.NS", "JWL.NS", "TRITURBINE.NS", "SHYAMMETL.NS", "ANANTRAJ.NS", "FSL.NS", "ATUL.NS", "CAMS.NS", "AFFLE.NS", "TEJASNET.NS", "FIVESTAR.NS", "APLLTD.NS", "ABSLAMC.NS", "JBMA.NS",
            "KAJARIACER.NS", "DEVYANI.NS", "GRSE.NS", "CYIENT.NS", "GSPL.NS", "FINCABLES.NS", "ELGIEQUIP.NS", "KIMS.NS", "KPIL.NS", "ASTERDM.NS", "RAMCOCEM.NS", "JINDALSAW.NS", "BIKAJI.NS", "AARTIIND.NS", "CIEINDIA.NS",
            "CHAMBLFERT.NS", "VINATIORGA.NS", "SIGNATURE.NS", "SWANENERGY.NS", "CONCORDBIO.NS", "NCC.NS", "VGUARD.NS", "PTCIL.NS", "SCHNEIDER.NS", "IIFL.NS", "RELAXO.NS", "HFCL.NS", "BLUEDART.NS", "CHALET.NS", "CELLO.NS",
            "AFCONS.NS", "AADHARHFC.NS", "WELCORP.NS", "TBOTEK.NS", "BATAINDIA.NS", "RRKABEL.NS", "TRIDENT.NS", "SAGILITY.NS", "JYOTHYLAB.NS", "FINPIPE.NS", "TITAGARH.NS", "IDFC.NS", "TECHNOE.NS", "SONATSOFTW.NS", "CREDITACC.NS",
            "KFINTECH.NS", "GESHIP.NS", "ERIS.NS", "AMBER.NS", "KARURVYSYA.NS", "CENTURYPLY.NS", "KIRLOSENG.NS", "JAIBALAJI.NS", "IFCI.NS", "ASTRAZEN.NS", "LMW.NS", "BBTC.NS", "BEML.NS", "BSOFT.NS", "RKFORGE.NS",
            "DCMSHRIRAM.NS", "NAVINFLUOR.NS", "WOCKPHARMA.NS", "ASAHIINDIA.NS", "CGCL.NS", "ZENSARTECH.NS", "IEX.NS", "HBLENGINE.NS", "NEWGEN.NS", "VENTIVE.NS", "APTUS.NS", "SOBHA.NS", "ANANDRATHI.NS", "BLS.NS", "JUBLPHARMA.NS",
            "WELSPUNLIV.NS", "TTML.NS", "NEULANDLAB.NS", "INDIAMART.NS", "PCBL.NS", "ACE.NS", "AKZOINDIA.NS", "MANAPPURAM.NS", "MGL.NS", "KIRLOSBROS.NS", "DOMS.NS", "PGEL.NS", "CLEAN.NS", "FINEORG.NS", "GRINFRA.NS",
            "ZENTEC.NS", "ACMESOLAR.NS", "RITES.NS", "REDINGTON.NS", "SAILIFE.NS", "KSB.NS", "UTIAMC.NS", "SANOFI.NS", "SPLPETRO.NS", "DATAPATTNS.NS", "NSLNISP.NS", "INDGN.NS", "GODREJAGRO.NS", "PVRINOX.NS", "RPOWER.NS",
            "NIVABUPA.NS", "NETWEB.NS", "EIDPARRY.NS", "CAPLIPOINT.NS", "GRAVITA.NS", "RAILTEL.NS", "VTL.NS", "ECLERX.NS", "GRANULES.NS", "SWSOLAR.NS", "RAINBOW.NS", "NAVA.NS", "ELECON.NS", "GPIL.NS", "SARDAEN.NS",
            "PRAJIND.NS", "AAVAS.NS", "DEEPAKFERT.NS", "INGERRAND.NS", "RAYMONDLSL.NS", "OLECTRA.NS", "ZYDUSWELL.NS", "HONASA.NS", "MMTC.NS", "CRAFTSMAN.NS", "IWEL.NS", "ZEEL.NS", "WESTLIFE.NS", "LTFOODS.NS", "GLS.NS",
            "JPPOWER.NS", "MINDACORP.NS", "CUB.NS", "INTELLECT.NS", "NUVOCO.NS", "RAYMOND.NS", "CHENNPETRO.NS", "AKUMS.NS", "VOLTAMP.NS", "TARIL.NS", "TTKPRESTIG.NS", "GENUSPOWER.NS", "ALOKINDS.NS", "RBLBANK.NS", "ENGINERSIN.NS",
            "RHIM.NS", "MARKSANS.NS", "HAPPSTMNDS.NS", "TEGA.NS", "AETHER.NS", "JMFINANCIL.NS", "SAFARI.NS", "CEATLTD.NS", "SCI.NS", "GMDCLTD.NS", "J&KBANK.NS", "MAHSCOOTER.NS", "USHAMART.NS", "TANLA.NS", "STAR.NS",
            "ELECTCAST.NS", "SANOFICONR.NS", "CANFINHOME.NS", "BALRAMCHIN.NS", "JUBLINGREA.NS", "EUREKAFORB.NS", "JSWHL.NS", "MAPMYINDIA.NS", "INDIACEM.NS", "KPIGREEN.NS", "REDTAPE.NS", "HAPPYFORGE.NS", "METROPOLIS.NS", "JKTYRE.NS", "INOXINDIA.NS",
            "CERA.NS", "ALKYLAMINE.NS", "VESUVIUS.NS", "QUESS.NS", "PRUDENT.NS", "BAJAJELEC.NS", "GRAPHITE.NS", "PNCINFRA.NS", "LEMONTREE.NS", "SAPPHIRE.NS", "NETWORK18.NS", "ISGEC.NS", "GALAXYSURF.NS", "RCF.NS", "RTNINDIA.NS",
            "SYMPHONY.NS", "PURVA.NS", "GPPL.NS", "BIRLACORPN.NS", "SAREGAMA.NS", "DBREALTY.NS", "BECTORFOOD.NS", "ARVIND.NS", "THOMASCOOK.NS", "SFL.NS", "RELINFRA.NS", "LATENTVIEW.NS", "EDELWEISS.NS", "HOMEFIRST.NS", "PNGJL.NS",
            "FORCEMOT.NS", "JUSTDIAL.NS", "ROUTE.NS", "HGINFRA.NS", "IONEXCHANG.NS", "RENUKA.NS", "VIJAYA.NS", "SAMMAANCAP.NS", "JKLAKSHMI.NS", "AZAD.NS", "ESABINDIA.NS", "GNFC.NS", "TIPSMUSIC.NS", "WABAG.NS", "TRIVENI.NS",
            "KNRCON.NS", "IIFLCAPS.NS", "ABDL.NS", "POWERMECH.NS", "CHOICEIN.NS", "KIRLPNU.NS", "AURIONPRO.NS", "CCL.NS", "SHAKTIPUMP.NS", "SBFC.NS", "PRSMJOHNSN.NS", "JLHL.NS", "TEXRAIL.NS", "CAMPUS.NS", "ITDCEM.NS",
            "SHRIPISTON.NS", "TIMETECHNO.NS", "SENCO.NS", "MASTEK.NS", "LLOYDSENGG.NS", "BBOX.NS", "RATEGAIN.NS", "GSFC.NS", "CMSINFO.NS", "RUSTOMJEE.NS", "MAXESTATES.NS", "VARROC.NS", "PGHL.NS", "MAHSEAMLES.NS", "HEG.NS",
            "RELIGARE.NS", "AVANTIFEED.NS", "ACI.NS", "EQUITASBNK.NS", "SYRMA.NS", "STARCEMENT.NS", "BLUEJET.NS", "ASKAUTOLTD.NS", "GRWRHITECH.NS", "SANSERA.NS", "FDC.NS", "JUNIPER.NS", "MEDPLUS.NS", "GALLANTT.NS", "KTKBANK.NS",
            "MAHLIFE.NS", "TCI.NS", "TVSSCS.NS", "GANESHHOUC.NS", "ANURAS.NS", "GMRP&UI.NS", "SUNTECK.NS", "EMBDL.NS", "RTNPOWER.NS", "MHRIL.NS", "RAJESHEXPO.NS", "GARFIBRES.NS", "EPIGRAL.NS", "JKPAPER.NS", "SHOPERSTOP.NS",
            "INFIBEAM.NS", "EPL.NS", "MOIL.NS", "ASTRAMICRO.NS", "CHEMPLASTS.NS", "SANDUMA.NS", "AHLUCONT.NS", "EMIL.NS", "DIACABS.NS", "TV18BRDCST.NS", "UJJIVANSFB.NS", "SHILPAMED.NS", "INDIASHLTR.NS", "PARADEEP.NS", "ETHOSLTD.NS",
            "ICIL.NS", "VMART.NS", "LXCHEM.NS", "WELENT.NS", "HCC.NS", "DBL.NS", "MIDHANI.NS", "PDSL.NS", "MANINFRA.NS", "IFBIND.NS", "TRANSRAILL.NS", "DHANUKA.NS", "TMB.NS", "ORCHPHARMA.NS", "NAZARA.NS",
            "RESPONIND.NS", "EMUDHRA.NS", "ARVINDFASN.NS", "DODLA.NS", "SUNDARMHLD.NS", "BALUFORGE.NS", "TIIL.NS", "INDIGOPNTS.NS", "SUPRAJIT.NS", "BALAMINES.NS", "GREENLAM.NS", "SPARC.NS", "JINDWORLD.NS", "SUDARSCHEM.NS", "UNIMECH.NS",
            "GABRIEL.NS", "ASHOKA.NS", "VIPIND.NS", "SURYAROSNI.NS", "BLACKBUCK.NS", "KRBL.NS", "GOKEX.NS", "SHARDAMOTR.NS", "AMIORG.NS", "NESCO.NS", "KESORAMIND.NS", "HNDFDS.NS", "ORIENTCEM.NS", "SOUTHBANK.NS", "TARC.NS",
            "BORORENEW.NS", "TDPOWERSYS.NS", "EASEMYTRIP.NS", "NIITMTS.NS", "BANSALWIRE.NS", "RALLIS.NS", "PRIVISCL.NS", "CEIGALL.NS", "JAICORPLTD.NS", "VSTIND.NS", "NFL.NS", "STLTECH.NS", "ICRA.NS", "PILANIINVS.NS", "ROLEXRINGS.NS",
            "AVL.NS", "GOCOLORS.NS", "UEL.NS", "GULFOILLUB.NS", "LUXIND.NS", "PCJEWELLER.NS", "GMMPFAUDLR.NS", "GAEL.NS", "SHAREINDIA.NS", "IXIGO.NS", "AGI.NS", "LLOYDSENT.NS", "PRINCEPIPE.NS", "PRICOLLTD.NS", "GHCL.NS",
            "ALLCARGO.NS", "JKIL.NS", "ITDC.NS", "TI.NS", "HCG.NS", "DBCORP.NS", "SIS.NS", "GUJALKALI.NS", "RSYSTEMS.NS", "PTC.NS", "ENTERO.NS", "SHARDACROP.NS", "INOXGREEN.NS", "AARTIPHARM.NS", "RAIN.NS",
            "CSBBANK.NS", "CYIENTDLM.NS", "THANGAMAYL.NS", "BANCOINDIA.NS", "JSFB.NS", "JCHAC.NS", "HEMIPROP.NS", "MTARTECH.NS", "NPST.NS", "ORIENTELEC.NS", "MANORAMA.NS", "MSTCLTD.NS", "PAISALO.NS", "KIRLOSIND.NS", "OPTIEMUS.NS",
            "ANUP.NS", "EIEL.NS", "BBL.NS", "DYNAMATECH.NS", "MASFIN.NS", "HEIDELBERG.NS", "ZAGGLE.NS", "HERITGFOOD.NS", "VAIBHAVGBL.NS", "KSCL.NS", "TEAMLEASE.NS", "CARTRADE.NS", "RBA.NS", "NEOGEN.NS", "SKIPPER.NS",
            "GANECOS.NS", "VRLLOG.NS", "AWFIS.NS", "BOROLTD.NS", "GOPAL.NS", "UTKARSHBNK.NS", "REFEX.NS", "E2E.NS", "WONDERLA.NS", "ADVENZYMES.NS", "BHARATRAS.NS", "SHAILY.NS", "BAJAJHIND.NS", "UNICHEMLAB.NS", "ORISSAMINE.NS",
            "PATELENG.NS", "YATHARTH.NS", "HARSHA.NS", "NOCIL.NS", "GATEWAY.NS", "ROSSARI.NS", "JAMNAAUTO.NS", "SUPRIYA.NS", "AARTIDRUGS.NS", "WEBELSOLAR.NS", "JISLJALEQS.NS", "THYROCARE.NS", "PITTIENG.NS", "PGIL.NS", "RAMKY.NS",
            "JTEKTINDIA.NS", "STYRENIX.NS", "HIKAL.NS", "UFLEX.NS", "PARAS.NS", "GREENPANEL.NS", "SHANTIGEAR.NS", "SUBROS.NS", "BOMDYEING.NS", "EMSLIMITED.NS", "INNOVACAP.NS", "MOBIKWIK.NS", "SUNCLAY.NS", "JAYNECOIND.NS", "GREENPLY.NS",
            "BALMLAWRIE.NS", "IMAGICAA.NS", "SEQUENT.NS", "ORIANA.NS", "BANARISUG.NS", "SAMHI.NS", "FEDFINA.NS", "BHAGCHEM.NS", "EXICOM.NS", "GREAVESCOT.NS", "AVALON.NS", "LGBBROSLTD.NS", "MEDIASSIST.NS", "AVANTEL.NS", "SKYGOLD.NS",
            "PFOCUS.NS", "ISMTLTD.NS", "SUNFLAG.NS", "FCL.NS", "MOREPENLAB.NS", "NORTHARC.NS", "VENUSPIPES.NS", "V2RETAIL.NS", "GUFICBIO.NS", "JTLIND.NS", "FIEMIND.NS", "CIGNITITEC.NS", "WSTCSTPAPR.NS", "IMFA.NS", "TCIEXP.NS",
            "KKCL.NS", "KPEL.NS", "JSLL.NS", "GOKULAGRO.NS", "KRN.NS", "SOTL.NS", "SULA.NS", "JNKINDIA.NS", "DCBBANK.NS", "DCXINDIA.NS", "VSTTILLERS.NS", "INDIAGLYCO.NS", "KSL.NS", "DHANI.NS", "KDDL.NS",
            "SPANDANA.NS", "VEEDOL.NS", "SEPC.NS", "ARTEMISMED.NS", "LUMAXTECH.NS", "POLYPLEX.NS", "SWARAJENG.NS", "HONDAPOWER.NS", "KINGFA.NS", "LAOPALA.NS", "ARVSMART.NS", "PARKHOTELS.NS", "MUTHOOTMF.NS", "HGS.NS", "STYLAMIND.NS",
            "HMT.NS", "MPSLTD.NS", "INDRAMEDCO.NS", "RPGLIFE.NS", "SANGHVIMOV.NS", "CARRARO.NS", "BEPL.NS", "JINDALPOLY.NS", "DATAMATICS.NS", "HPL.NS", "DALMIASUG.NS", "ALEMBICLTD.NS", "SCILAL.NS", "HATHWAY.NS", "TCNSBRANDS.NS",
            "CARERATING.NS", "SHK.NS", "SBCL.NS", "MTNL.NS", "SEAMECLTD.NS", "INDOSTAR.NS", "SERVOTECH.NS", "ASHIANA.NS", "SANDHAR.NS", "GIPCL.NS", "DPABHUSHAN.NS", "EPACK.NS", "SINDHUTRAD.NS", "BAJAJCON.NS", "SSWL.NS",
            "QUICKHEAL.NS", "NUCLEUS.NS", "DELTACORP.NS", "NAVNETEDUL.NS", "TIRUMALCHM.NS", "BFUTILITIE.NS", "MAHLOG.NS", "RPSGVENT.NS", "GENSOL.NS", "GOLDIAM.NS", "VPRPL.NS", "MARINE.NS", "PRAKASH.NS", "GEOJITFSL.NS", "GOODLUCK.NS",
            "MAITHANALL.NS", "KITEX.NS", "SJS.NS", "PRECWIRE.NS", "GTLINFRA.NS", "DCAL.NS", "FLAIR.NS", "SANATHAN.NS", "TVSSRICHAK.NS", "PFS.NS", "SAKSOFT.NS", "APOLLO.NS", "CAPACITE.NS", "REPCOHOME.NS", "MARATHON.NS",
            "INDOCO.NS", "BAJEL.NS", "KCP.NS", "SURAJEST.NS", "ASHAPURMIN.NS", "WENDT.NS", "GENESYS.NS", "JASH.NS", "POKARNA.NS", "ADFFOODS.NS", "EVEREADY.NS", "SALASAR.NS", "FINOPB.NS", "SAGCEM.NS", "NSIL.NS",
            "TASTYBITE.NS", "RPEL.NS", "HINDOILEXP.NS", "SUVEN.NS", "KOLTEPATIL.NS", "PREMEXPLN.NS", "SPECTRUM.NS", "NRBBEARING.NS", "DOLLAR.NS", "ORIENTHOT.NS", "SOMANYCERA.NS", "IDEAFORGE.NS", "FOSECOIND.NS", "VADILALIND.NS", "AJMERA.NS",
            "HITECH.NS", "AUTOAXLES.NS", "GLOBUSSPR.NS", "GEPIL.NS", "TCPLPACK.NS", "NILKAMAL.NS", "ARKADE.NS", "SUMMITSEC.NS", "RAJRATAN.NS", "DREDGECORP.NS", "STANLEY.NS", "VISHNU.NS", "FUSION.NS", "THEJO.NS", "SHALBY.NS",
            "DEEPINDS.NS", "VENKEYS.NS", "HLEGLAS.NS", "KICL.NS", "DAMCAPITAL.NS", "VINDHYATEL.NS", "FILATEX.NS", "SIYSIL.NS", "MONARCH.NS", "MAYURUNIQ.NS", "MMFL.NS", "UNITECH.NS", "HUHTAMAKI.NS", "RANEHOLDIN.NS", "SMLISUZU.NS",
            "VAKRANGEE.NS", "SASKEN.NS", "KALAMANDIR.NS", "RPTECH.NS", "HINDWAREAP.NS", "PSPPROJECT.NS", "KRSNAA.NS", "CONFIPET.NS", "XPROINDIA.NS", "LANDMARK.NS", "SENORES.NS", "STYLEBAAZA.NS", "STOVEKRAFT.NS", "SOLARA.NS", "DCW.NS",
            "SABTNL.NS", "JYOTISTRUC.NS", "ACCELYA.NS", "EIHAHOTELS.NS", "PENIND.NS", "SMSPHARMA.NS", "DOLATALGO.NS", "DISHTV.NS", "MANGLMCEM.NS", "BFINVEST.NS", "PRECAM.NS", "IOLCP.NS", "INTERARCH.NS", "MOLDTKPAC.NS", "RAMRAT.NS",
            "JUBLINDS.NS", "LUMAXIND.NS", "INDIANHUME.NS", "MANINDS.NS", "UDS.NS", "INSECTICID.NS", "MOL.NS", "THEMISMED.NS", "DREAMFOLKS.NS", "PIXTRANS.NS", "ECOSMOBLTY.NS", "PARACABLES.NS", "ESAFSFB.NS", "DOLPHIN.NS", "INDOTECH.NS",
            "TARSONS.NS", "DEN.NS", "KMEW.NS", "HMAAGRO.NS", "PANAMAPET.NS", "NELCO.NS", "AEROFLEX.NS", "MOTISONS.NS", "PARAGMILK.NS", "FMGOETZE.NS", "VIDHIING.NS", "IPL.NS", "OWAIS.NS", "NITINSPIN.NS", "APOLLOPIPE.NS",
            "63MOONS.NS", "DIAMONDYD.NS", "AXISCADES.NS", "UGROCAP.NS", "SANSTAR.NS", "ASTEC.NS", "RUPA.NS", "CUPID.NS", "UNIVCABLES.NS", "TATVA.NS", "SPAL.NS", "CENTUM.NS", "CARYSIL.NS", "BARBEQUE.NS", "VSSL.NS",
            "GREENPOWER.NS", "RAMCOIND.NS", "TIL.NS", "MUKANDLTD.NS", "JITFINFRA.NS", "SANGHIIND.NS", "NIITLTD.NS", "TTKHLTCARE.NS", "AHL.NS", "IKIO.NS", "POCL.NS", "OMAXE.NS", "PNBGILTS.NS", "KIRIINDUS.NS", "DEEDEV.NS",
            "AMRUTANJAN.NS", "KODYTECH.NS", "YASHO.NS", "ATFL.NS", "COSMOFIRST.NS", "APCOTEXIND.NS", "SDBL.NS", "HESTERBIO.NS", "GANDHAR.NS", "IGARASHI.NS", "ALPEXSOLAR.NS", "HUBTOWN.NS", "PLATIND.NS", "ANDHRAPAP.NS", "CANTABIL.NS",
            "GOCLCORP.NS", "SURAKSHA.NS", "UNIPARTS.NS", "SBGLP.NS", "NAVKARCORP.NS", "HIL.NS", "SESHAPAPER.NS", "BLKASHYAP.NS", "DLINKINDIA.NS", "SATIN.NS", "IFGLEXPOR.NS", "EKC.NS", "ALICON.NS", "SANGAMIND.NS", "TAJGVK.NS",
            "TALBROAUTO.NS", "UNIECOM.NS", "MICEL.NS", "EXPLEOSOL.NS", "BLSE.NS", "VERANDA.NS", "AWHCL.NS", "JAGRAN.NS", "DIVGIITTS.NS", "JINDRILL.NS", "HARIOMPIPE.NS", "MBAPL.NS", "YATRA.NS", "SHRIRAMPPS.NS", "VERTOZ.NS",
            "MASTERTR.NS", "WINDLAS.NS", "JPASSOCIAT.NS", "GMBREW.NS", "UDAICEMENT.NS", "WEL.NS", "STERTOOLS.NS", "WHEELS.NS", "RAMASTEEL.NS", "ROSSTECH.NS", "BSHSL.NS", "RELTD.NS", "GPTINFRA.NS", "SIRCA.NS", "GKWLIMITED.NS",
            "CAMLINFINE.NS", "IGPL.NS", "DANISH.NS", "SALZERELEC.NS", "GRPLTD.NS", "ROTO.NS", "SYNCOMF.NS", "SIGACHI.NS", "DPSCLTD.NS", "MUFIN.NS", "HERANBA.NS", "EXCELINDUS.NS", "GNA.NS", "SUYOG.NS", "SURYODAY.NS",
            "RIIL.NS", "ATULAUTO.NS", "GTPL.NS", "SADHNANIQ.NS", "ADORWELD.NS", "PANACEABIO.NS", "SAHASRA.NS", "AGARIND.NS", "DSSL.NS", "GODAVARIB.NS", "BIGBLOC.NS", "HIRECT.NS", "SWELECTES.NS", "DCMSRIND.NS", "BCG.NS",
            "WALCHANNAG.NS", "IRMENERGY.NS", "BHARATWIRE.NS", "PENINLAND.NS", "INDNIPPON.NS", "KOKUYOCMLN.NS", "ARMANFIN.NS", "MADRASFERT.NS", "ZOTA.NS", "BOROSCI.NS", "SPIC.NS", "OAL.NS", "NDRAUTO.NS", "HIMATSEIDE.NS", "HITECHGEAR.NS",
            "OMINFRAL.NS", "BETA.NS", "TEXINFRA.NS", "AMNPLST.NS", "MANGCHEFER.NS", "DYCL.NS", "BCLIND.NS", "RML.NS", "MSPL.NS", "ASALCBR.NS", "EVERESTIND.NS", "CEWATER.NS", "MONTECARLO.NS", "TFCILTD.NS", "ALLDIGI.NS",
            "BUTTERFLY.NS", "EIMCOELECO.NS", "SMCGLOBAL.NS", "5PAISA.NS", "MATRIMONY.NS", "YUKEN.NS", "IMPAL.NS", "LIKHITHA.NS", "KABRAEXTRU.NS", "SUBEXLTD.NS", "FAIRCHEMOR.NS", "SPORTKING.NS", "TECHLABS.NS", "TBZ.NS", "STEELCAS.NS",
            "WINDMACHIN.NS", "CENTRUM.NS", "VINCOFE.NS", "ARIHANTSUP.NS", "DVL.NS", "CLSEL.NS", "HEXATRADEX.NS", "TNPL.NS", "RICOAUTO.NS", "MAMATA.NS", "RAMCOSYS.NS", "SHANKARA.NS", "ORIENTTECH.NS", "PVSL.NS", "PUNJABCHEM.NS",
            "ASIANENE.NS", "GPTHEALTH.NS", "ANDHRSUGAR.NS", "SOLEX.NS", "KRISHANA.NS", "AGIIL.NS", "KELLTONTEC.NS", "JGCHEM.NS", "RISHABH.NS", "ACLGATI.NS", "CENTENKA.NS", "VIMTALABS.NS", "KAMDHENU.NS", "VASCONEQ.NS", "BESTAGRO.NS",
            "REMUS.NS", "ADSL.NS", "SHREDIGCEM.NS", "KERNEX.NS", "LINCOLN.NS", "SPCENET.NS", "WEALTH.NS", "SIGNPOST.NS", "ONEPOINT.NS", "VLEGOV.NS", "MACPOWER.NS", "HERCULES.NS", "VHL.NS", "TVTODAY.NS", "MANALIPETC.NS",
            "CAPITALSFB.NS", "BLISSGVS.NS", "ESTER.NS", "WCIL.NS", "CHEMFAB.NS", "GRMOVER.NS", "SAURASHCEM.NS", "RGL.NS", "KROSS.NS", "SPMLINFRA.NS", "DHAMPURSUG.NS", "NGLFINE.NS", "XCHANGING.NS", "KECL.NS", "CREST.NS",
            "KOPRAN.NS", "SELAN.NS", "MUKKA.NS", "AVADHSUGAR.NS", "HLVLTD.NS", "SATINDLTD.NS", "AVTNPL.NS", "RAJRILTD.NS", "PPL.NS", "VLSFINANCE.NS", "DWARKESH.NS", "SNOWMAN.NS", "RKSWAMY.NS", "PDMJEPAPER.NS", "GULPOLY.NS",
            "JAGSNPHARM.NS", "INDOAMIN.NS", "SANDESH.NS", "ASAL.NS", "CONTROLPR.NS", "SAHANA.NS", "ELECTHERM.NS", "SIMPLEXINF.NS", "OSWALGREEN.NS", "STEELXIND.NS", "KUANTUM.NS", "GICHSGFIN.NS", "GALAPREC.NS", "UTTAMSUGAR.NS", "ICEMAKE.NS",
            "HEUBACHIND.NS", "RADHIKAJWE.NS", "NDTV.NS", "DIFFNKG.NS", "KSOLVES.NS", "ARROWGREEN.NS", "MVGJL.NS", "MUFTI.NS", "DHUNINV.NS", "MAXIND.NS", "PAKKA.NS", "ROSSELLIND.NS", "CREATIVE.NS", "KOTHARIPET.NS", "APTECHT.NS",
            "INDORAMA.NS", "HARDWYN.NS", "NACLIND.NS", "C2C.NS", "SRHHYPOLTD.NS", "NELCAST.NS", "UNIENTER.NS", "SATIA.NS", "VILAS.NS", "VINYAS.NS", "MUNJALAU.NS", "FAZE3Q.NS", "ANUHPHR.NS", "BAJAJHCARE.NS", "ATL.NS",
            "MAGADSUGAR.NS", "BLAL.NS", "ELIN.NS", "GGBL.NS", "SHALPAINTS.NS", "JAYBARMARU.NS", "GANESHBE.NS", "DHARMAJ.NS", "AGSTRA.NS", "BASILIC.NS", "SUTLEJTEX.NS", "TREL.NS", "NAHARSPING.NS", "VALIANTORG.NS", "ZEEMEDIA.NS",
            "ZUARIIND.NS", "SARTELE.NS", "INFOBEAN.NS", "AIMTRON.NS", "URJA.NS", "STCINDIA.NS", "KRYSTAL.NS", "GANDHITUBE.NS", "CELLECOR.NS", "SSEGL.NS", "THEINVEST.NS", "KAMOPAINTS.NS", "SASTASUNDR.NS", "DENTALKART.NS", "KRITI.NS",
            "KRISHNADEF.NS", "ARIHANTCAP.NS", "NINSYS.NS", "EMKAYTOOLS.NS", "AYMSYNTEX.NS", "NCLIND.NS", "ENIL.NS", "APS.NS", "RSWM.NS", "ASIANTILES.NS", "ORIENTPPR.NS", "KOTYARK.NS", "BODALCHEM.NS", "DHANBANK.NS", "BIRLAMONEY.NS",
            "INNOVANA.NS", "GVKPIL.NS", "GHCLTEXTIL.NS", "SICALLOG.NS", "RATNAVEER.NS", "SHIVALIK.NS", "AMBIKCO.NS", "GFLLIMITED.NS", "ROHLTD.NS", "LINC.NS", "PRIMESECU.NS", "20MICRONS.NS", "RUSHIL.NS", "SBC.NS", "RACLGEAR.NS",
            "RITCO.NS", "MINDTECK.NS", "CHEMCON.NS", "ESFL.NS", "SARVESHWAR.NS", "FILATFASH.NS", "ZODIAC.NS", "SILVERTUC.NS", "GIRIRAJ.NS", "CSLFINANCE.NS", "ESSARSHPNG.NS", "MALLCOM.NS", "TRACXN.NS", "VHLTD.NS", "STEL.NS",
            "GARUDA.NS", "VISAKAIND.NS", "JAYAGROGN.NS", "OSWALAGRO.NS", "UGARSUGAR.NS", "ALLETEC.NS", "ELDEHSG.NS", "JPOLYINVST.NS", "ZUARI.NS", "DBOL.NS", "BHAGERIA.NS", "DECCANCE.NS", "MMP.NS", "ONWARDTEC.NS", "RUBYMILLS.NS",
            "FOODSIN.NS", "SJLOGISTIC.NS", "JINDALPHOT.NS", "CAREERP.NS", "RADIANTCMS.NS", "ONMOBILE.NS", "REPRO.NS", "COFFEEDAY.NS", "SHREEPUSHK.NS", "GEECEE.NS", "VMARCIND.NS", "GSLSU.NS", "SAKUMA.NS", "HPAL.NS", "SUKHJITS.NS",
            "TIRUPATI.NS", "MAANALU.NS", "GLOSTERLTD.NS", "LIBERTSHOE.NS", "SPENCERS.NS", "NECLIFE.NS", "ACL.NS", "TPLPLASTEH.NS", "SARLAPOLY.NS", "WSI.NS", "FOCUS.NS", "TNPETRO.NS", "CHEVIOT.NS", "TRANSWORLD.NS", "CHEMBOND.NS",
            "RBL.NS", "KDL.NS", "HINDCOMPOS.NS", "SPECIALITY.NS", "DENORA.NS", "DBEIL.NS", "SURAJLTD.NS", "DIGISPICE.NS", "APEX.NS", "ALBERTDAVD.NS", "SCHAND.NS", "TAC.NS", "TOLINS.NS", "MANBA.NS", "NDL.NS",
            "PARSVNATH.NS", "WANBURY.NS", "VRAJ.NS", "VIKASLIFE.NS", "CCCL.NS", "BIL.NS", "PASHUPATI.NS", "INDSWFTLAB.NS", "DMCC.NS", "KHAICHEM.NS", "PVP.NS", "ANNAPURNA.NS", "JAYBEE.NS", "AFFORDABLE.NS", "PLASTIBLEN.NS",
            "BIRLACABLE.NS", "RPPINFRA.NS", "RBMINFRA.NS", "EMAMIPAP.NS", "INDOTHAI.NS", "VISHNUINFR.NS", "RVTH.NS", "NRL.NS", "FOCE.NS", "TVSELECT.NS", "MENONBE.NS", "NITCO.NS", "VINYLINDIA.NS", "PYRAMID.NS", "LOKESHMACH.NS",
            "ASHIMASYN.NS", "BALAJITELE.NS", "BEDMUTHA.NS", "HMVL.NS", "SAKAR.NS", "LGHL.NS", "GOACARBON.NS", "KHADIM.NS", "DEEPENR.NS", "CONSOFINVT.NS", "MBLINFRA.NS", "NAHARPOLY.NS", "RBZJEWEL.NS", "NRAIL.NS", "MEGATHERM.NS",
            "KRITINUT.NS", "COOLCAPS.NS", "DONEAR.NS", "GANESHIN.NS", "RSSOFTWARE.NS", "ADVANIHOTR.NS", "SKMEGGPROD.NS", "SILINV.NS", "ABSMARINE.NS", "CYBERTECH.NS", "TCLCONS.NS", "IRIS.NS", "KNAGRI.NS", "MOLDTECH.NS", "RACE.NS",
            "MOS.NS", "PCCL.NS", "DAVANGERE.NS", "SUPREMEPWR.NS", "BCONCEPTS.NS", "ALANKIT.NS", "SREEL.NS", "IITL.NS", "INDOBORAX.NS", "TGL.NS", "NBIFIN.NS", "MUNJALSHOW.NS", "NAGAFERT.NS", "SRM.NS", "NOVAAGRI.NS",
            "KRONOX.NS", "IZMO.NS", "REMSONSIND.NS", "DPWIRES.NS", "VIKASECO.NS", "PAVNAIND.NS", "NAHARINDUS.NS", "ATMASTCO.NS", "DRONE.NS", "SAHAJSOLAR.NS", "AVG.NS", "DICIND.NS", "KORE.NS", "TARACHAND.NS", "MANAKSIA.NS",
            "BALAJEE.NS", "SPCL.NS", "FCSSOFT.NS", "GENUSPAPER.NS", "EFFWA.NS", "MEDICAMEQ.NS", "ASMS.NS", "SGIL.NS", "WTICAB.NS", "RMDRIP.NS", "KAYA.NS", "PRECOT.NS", "ORIENTCER.NS", "AURUM.NS", "EMKAY.NS",
            "XTGLOBAL.NS", "MIRZAINT.NS", "KRISHIVAL.NS", "AARTISURF.NS", "HINDMOTORS.NS", "ORICONENT.NS", "HTMEDIA.NS", "HIGREEN.NS", "BPL.NS", "KAMATHOTEL.NS", "PTL.NS", "SSDL.NS", "ACCENTMIC.NS", "RCOM.NS", "CLEDUCATE.NS",
            "MUTHOOTCAP.NS", "HCL-INSYS.NS", "KCPSUGIND.NS", "INDOUS.NS", "KANORICHEM.NS", "PREMIERPOL.NS", "LAWSIKHO.NS", "SHIVAMAUTO.NS", "VINSYS.NS", "INTLCONV.NS", "IRISDOREME.NS", "MODISONLTD.NS", "BALAXI.NS", "3IINFOLTD.NS", "NAHARCAP.NS",
            "MAZDA.NS", "ZIMLAB.NS", "KILITCH.NS", "GEEKAYWIRE.NS", "DIAMINESQ.NS", "SINCLAIR.NS", "AXITA.NS", "URAVI.NS", "ASAHISONG.NS", "MIRCELECTR.NS", "TRF.NS", "IFBAGRO.NS", "UYFINCORP.NS", "PROV.NS", "APCL.NS",
            "SADBHAV.NS", "SRD.NS", "VALIANTLAB.NS", "VIVIANA.NS", "TEMBO.NS", "ORIENTBELL.NS", "MANAKCOAT.NS", "FROG.NS", "NILAINFRA.NS", "INSPIRISYS.NS", "GOKUL.NS", "UTSSAV.NS", "BANSWRAS.NS", "ALMONDZ.NS", "ELGIRUBCO.NS",
            "UNIDT.NS", "KOTHARIPRO.NS", "RADIOCITY.NS", "ORBTEXP.NS", "MEGASOFT.NS", "SHREEKARNI.NS", "IL&FSENGG.NS", "LYKALABS.NS", "SOFTTECH.NS", "SRGHFL.NS", "TRUST.NS", "AUTOIND.NS", "LEMERITE.NS", "DYNPRO.NS", "KAPSTON.NS",
            "SWARAJ.NS", "DUGLOBAL.NS", "EUROBOND.NS", "ZTECH.NS", "OCCLLTD.NS", "UFO.NS", "DCI.NS", "HARRMALAYA.NS", "NILASPACES.NS", "VSTL.NS", "VARDHACRLC.NS", "PHANTOMFX.NS", "BBTCL.NS", "ESCONET.NS", "EIFFL.NS",
            "VENUSREM.NS", "VIPULLTD.NS", "SHEMAROO.NS", "VIESL.NS", "SEJALLTD.NS", "JETAIRWAYS.NS", "NAMOEWASTE.NS", "PRATHAM.NS", "RUBFILA.NS", "SHREERAMA.NS", "KOTARISUG.NS", "AFIL.NS", "APOLSINHOT.NS", "KRISHCA.NS", "EMMIL.NS",
            "KRITIKA.NS", "PRITIKAUTO.NS", "SAKHTISUG.NS", "MAWANASUG.NS", "CGRAPHICS.NS", "SHERA.NS", "AIRAN.NS", "BEWLTD.NS", "HITECHCORP.NS", "PODDARMENT.NS", "TBI.NS", "NIPPOBATRY.NS", "DYNAMIC.NS", "NDGL.NS", "SAAKSHI.NS",
            "MANORG.NS", "OBSCP.NS", "PASUPTAC.NS", "S&SPOWER.NS", "ATLANTAA.NS", "PROZONER.NS", "KATARIA.NS", "MGEL.NS", "DJML.NS", "AVPINFRA.NS", "CINELINE.NS", "DCMNVL.NS", "MANOMAY.NS", "SCPL.NS", "BRNL.NS",
            "PONNIERODE.NS", "ABAN.NS", "EMAMIREAL.NS", "NEPHROCARE.NS", "EXXARO.NS", "ABINFRA.NS", "CHAVDA.NS", "NATHBIOGEN.NS", "TCL.NS", "RUCHIRA.NS", "MANAKSTEEL.NS", "TIRUPATIFL.NS", "UCAL.NS", "UNIVPHOTO.NS", "OSIAHYPER.NS",
            "SINTERCOM.NS", "LAL.NS", "ESSENTIA.NS", "TRU.NS", "SIGMA.NS", "SAHYADRI.NS", "MEDICO.NS", "GLOBALVECT.NS", "SUMIT.NS", "IVC.NS", "BAHETI.NS", "JAYSREETEA.NS", "WINSOL.NS", "PURVFLEXI.NS", "SHIVAUM.NS",
            "GLOBAL.NS", "INFINIUM.NS", "GUJAPOLLO.NS", "ARIES.NS", "SMSLIFE.NS", "IEML.NS", "ASIANHOTNR.NS", "SKP.NS", "TRIGYN.NS", "VIPCLOTHNG.NS", "BYKE.NS", "MWL.NS", "NDLVENTURE.NS", "MKPL.NS", "SUNDRMBRAK.NS",
            "AVONMORE.NS", "GULFPETRO.NS", "PLAZACABLE.NS", "MAHEPC.NS", "SYSTANGO.NS", "VARDMNPOLY.NS", "BASML.NS", "KARNIKA.NS", "PARIN.NS", "SHREYANIND.NS", "PELATRO.NS", "UMAEXPORTS.NS", "RNFI.NS", "STARPAPER.NS", "CCHHL.NS",
            "LORDSCHLO.NS", "GPECO.NS", "DRCSYSTEMS.NS", "ETML.NS", "RHL.NS", "GOYALSALT.NS", "BGRENERGY.NS", "GOLDTECH.NS", "RAMAPHO.NS", "REPL.NS", "SOUTHWEST.NS", "SHYAMCENT.NS", "COASTCORP.NS", "NEWJAISA.NS", "TREJHARA.NS",
            "KMSUGAR.NS", "RVHL.NS", "BROOKS.NS", "KCEIL.NS", "SPECTSTM.NS", "REFRACTORY.NS", "WELINV.NS", "ABCOTS.NS", "RANASUG.NS", "INFOLLION.NS", "OSELDEVICE.NS", "INTENTECH.NS", "MURUDCERA.NS", "MCLEODRUSS.NS", "USK.NS",
            "BHAGYANGR.NS", "VISASTEEL.NS", "ZODIACLOTH.NS", "SHRADHA.NS", "VISHWARAJ.NS", "A2ZINFRA.NS", "RANEENGINE.NS", "PILITA.NS", "EFACTOR.NS", "ROCKINGDCE.NS", "ODIGMA.NS", "FRESHARA.NS", "RAJTV.NS", "DEVIT.NS", "SVLL.NS",
            "MARALOVER.NS", "TECHERA.NS", "NECCLTD.NS", "RUCHINFRA.NS", "INDOWIND.NS", "VIRINCHI.NS", "SURANAT&P.NS", "FELIX.NS", "RAJMET.NS", "K2INFRA.NS", "SDREAMS.NS", "POSITRON.NS", "PAR.NS", "LAKSHYA.NS", "AARON.NS",
            "MEGASTAR.NS", "LANCORHOL.NS", "MODIRUBBER.NS", "PROPEQUITY.NS", "SURANI.NS", "KCK.NS", "MAGNUM.NS", "NURECA.NS", "KBCGLOBAL.NS", "ZEELEARN.NS", "NIRMAN.NS", "RAMANEWS.NS", "PPAP.NS", "GOLDKART.NS", "MAHASTEEL.NS",
            "RPPL.NS", "CRAYONS.NS", "GOLDSTAR.NS", "LGBFORGE.NS", "TTL.NS", "THOMASCOTT.NS", "IEL.NS", "PRLIND.NS", "CROWN.NS", "VETO.NS", "RKEC.NS", "MANCREDIT.NS", "AURDIS.NS", "COMSYN.NS", "CORDSCABLE.NS",
            "NOIDATOLL.NS", "TAKE.NS", "OMAXAUTO.NS", "SUPREMEINF.NS", "USHAFIN.NS", "ANLON.NS", "STARTECK.NS", "ALPHAGEO.NS", "PARAGON.NS", "SHIVATEX.NS", "DTIL.NS", "DELPHIFX.NS", "ROXHITECH.NS", "JEYYAM.NS", "AKANKSHA.NS",
            "OCCL.NS", "DUCON.NS", "SONAMLTD.NS", "GINNIFILA.NS", "AHLEAST.NS", "SADHAV.NS", "UNITEDPOLY.NS", "INDTERRAIN.NS", "TUNWAL.NS", "KANPRPLA.NS", "INVENTURE.NS", "IPHL.NS", "AKSHARCHEM.NS", "VR.NS", "INNOMET.NS",
            "PIGL.NS", "CANARYS.NS", "CMNL.NS", "NITIRAJ.NS", "HINDCON.NS", "SMARTLINK.NS", "DIGIKORE.NS", "MADHUSUDAN.NS", "PRAXIS.NS", "MASON.NS", "KONSTELEC.NS", "EQUIPPP.NS", "PANSARI.NS", "DGCONTENT.NS", "ZEAL.NS",
            "GENCON.NS", "PRAENG.NS", "AERON.NS", "UNIVASTU.NS", "LOYALTEX.NS", "ARHAM.NS", "PANACHE.NS", "SUPERHOUSE.NS", "RBS.NS", "SMLT.NS", "GRCL.NS", "TIPSFILMS.NS", "COMPUSOFT.NS", "JMA.NS", "SADBHIN.NS",
            "ARCHIDPLY.NS", "ONDOOR.NS", "DCG.NS", "ANIKINDS.NS", "BSL.NS", "ISFT.NS", "UMANGDAIRY.NS", "AGARWALTUF.NS", "LLOYDS.NS", "NIRAJ.NS", "MAHAPEXLTD.NS", "SONAMAC.NS", "OSWALSEEDS.NS", "SAH.NS", "RAJSREESUG.NS",
            "OILCOUNTUB.NS", "YASHOPTICS.NS", "ALPA.NS", "ENSER.NS", "TAINWALCHM.NS", "SURANASOL.NS", "EMMBI.NS", "DPEL.NS", "SECL.NS", "AARTECH.NS", "SHREEOSFM.NS", "ASPINWALL.NS", "SHAH.NS", "UNITEDTEA.NS", "AMJLAND.NS",
            "TROM.NS", "LAGNAM.NS", "MAXPOSURE.NS", "UNIHEALTH.NS", "ESPRIT.NS", "ENVIRO.NS", "DELAPLEX.NS", "IVP.NS", "CORALFINAC.NS", "SIGIND.NS", "KLL.NS", "CAPTRUST.NS", "INCREDIBLE.NS", "HINDNATGLS.NS", "GRETEX.NS",
            "SSFL.NS", "GTL.NS", "INDBANK.NS", "SHIGAN.NS", "WORTH.NS", "INM.NS", "LOVABLE.NS", "QMSMEDI.NS", "SOMICONVEY.NS", "AARVI.NS", "GILLANDERS.NS", "TEXMOPIPES.NS", "GVPTECH.NS", "CTE.NS", "URBAN.NS",
            "SALSTEEL.NS", "MODTHREAD.NS", "BEACON.NS", "WEIZMANIND.NS", "IL&FSTRANS.NS", "PURPLEUTED.NS", "RAJPUTANA.NS", "DENEERS.NS", "GSS.NS", "BAGFILMS.NS", "CENTEXT.NS", "BALPHARMA.NS", "DHRUV.NS", "PRITIKA.NS", "KALYANIFRG.NS",
            "ARVEE.NS", "SATECH.NS", "KHFM.NS", "MANAKALUCO.NS", "JHS.NS", "PRITI.NS", "QUESTLAB.NS", "MHLXMIRU.NS", "MAITREYA.NS", "FLEXITUFF.NS", "BAFNAPH.NS", "HDIL.NS", "AIROLAM.NS", "MAHESHWARI.NS", "NAMAN.NS",
            "RAJINDLTD.NS", "VITAL.NS", "KREBSBIO.NS", "VAISHALI.NS", "FIDEL.NS", "BAIDFIN.NS", "XELPMOC.NS", "DUCOL.NS", "MANGALAM.NS", "SYLVANPLY.NS", "MDL.NS", "KEYFINSERV.NS", "GANGESSECU.NS", "HILTON.NS", "USASEEDS.NS",
            "MUKTAARTS.NS", "RHFL.NS", "DCM.NS", "JOCIL.NS", "LAMBODHARA.NS", "SIL.NS", "ATAM.NS", "SELMC.NS", "SUNLITE.NS", "RULKA.NS", "PRIZOR.NS", "SIKKO.NS", "CHETANA.NS", "ANMOL.NS", "GREENCHEF.NS",
            "SHEKHAWATI.NS", "FORCAS.NS", "TARMAT.NS", "SPLIL.NS", "SETCO.NS", "FONEBOX.NS", "MRO-TEK.NS", "EROSMEDIA.NS", "AISL.NS", "AKI.NS", "APEXECO.NS", "HOMESFY.NS", "UHTL.NS", "JAINAM.NS", "LATTEYS.NS",
            "AMBEY.NS", "REGENCERAM.NS", "BHANDARI.NS", "RELCHEMQ.NS", "ENFUSE.NS", "ANSALAPI.NS", "IPSL.NS", "GICL.NS", "INDIANCARD.NS", "MITCON.NS", "ZENITHDRUG.NS", "DIGIDRIVE.NS", "HVAX.NS", "TOUCHWOOD.NS", "WIPL.NS",
            "KAKATCEM.NS", "HPIL.NS", "RAPPID.NS", "SHRITECH.NS", "SURYALAXMI.NS", "ACCURACY.NS", "PULZ.NS", "DRSDILIP.NS", "DBSTOCKBRO.NS", "BHARATGEAR.NS", "EFORCE.NS", "ASHALOG.NS", "PATINTLOG.NS", "BEARDSELL.NS", "ARTNIRMAN.NS",
            "PRAMARA.NS", "AKSHOPTFBR.NS", "ZENITHEXPO.NS", "PRAKASHSTL.NS", "KOHINOOR.NS", "ALUWIND.NS", "SALONA.NS", "DESTINY.NS", "BTML.NS", "AAREYDRUGS.NS", "PKTEA.NS", "DECCANTRAN.NS", "GAYAPROJ.NS", "KEL.NS", "VISESHINFO.NS",
            "SRIVASAVI.NS", "IBLFL.NS", "3RDROCK.NS", "AVROIND.NS", "SOTAC.NS", "ASCOM.NS", "PALASHSECU.NS", "MADHAVBAUG.NS", "AAATECH.NS", "STEELCITY.NS", "PRUDMOULI.NS", "PIONEEREMB.NS", "VASWANI.NS", "TOTAL.NS", "LOTUSEYE.NS",
            "AUSOMENT.NS", "SWASTIK.NS", "CUBEXTUB.NS", "TFL.NS", "SHUBHSHREE.NS", "GLOBE.NS", "LPDC.NS", "SFML.NS", "BAWEJA.NS", "APRAMEYA.NS", "SHAHALLOYS.NS", "SEMAC.NS", "VEEKAYEM.NS", "TPHQ.NS", "FIBERWEB.NS",
            "FRETAIL.NS", "DHANLAXMI.NS", "MOTOGENFIN.NS", "ZENITHSTL.NS", "NMSTEEL.NS", "MACOBSTECH.NS", "PSFL.NS", "AESTHETIK.NS", "GOYALALUM.NS", "SUNDARAM.NS", "DTL.NS", "SOMATEX.NS", "AHLADA.NS", "HOLMARC.NS", "TRANSTEEL.NS",
            "TERASOFT.NS", "EXCEL.NS", "SAMPANN.NS", "SEL.NS", "LASA.NS", "AJOONI.NS", "SCML.NS", "PARTYCRUS.NS", "AUSL.NS", "AMDIND.NS", "BRACEPORT.NS", "BVCL.NS", "IDENTICAL.NS", "FCONSUMER.NS", "AARVEEDEN.NS",
            "BANKA.NS", "WOMANCART.NS", "MASTER.NS", "DHARIWAL.NS", "INDSWFTLTD.NS", "SKIL.NS", "GROBTEA.NS", "AGRITECH.NS", "TIMESGTY.NS", "ENERGYDEV.NS", "ALKALI.NS", "YAARI.NS", "VINNY.NS", "AAKASH.NS", "PALREDTEC.NS",
            "BLUEPEBBLE.NS", "NAGREEKEXP.NS", "OBCL.NS", "LAMOSAIC.NS", "AVIANSH.NS", "MARCO.NS", "SECURKLOUD.NS", "PARAMATRIX.NS", "CEREBRAINT.NS", "HECPROJECT.NS", "ASPIRE.NS", "TOKYOPLAST.NS", "PARASPETRO.NS", "SUVIDHAA.NS", "VLINFRA.NS",
            "GRAPHISAD.NS", "MCL.NS", "SAIFL.NS", "DIVYADHAN.NS", "DANGEE.NS", "MCON.NS", "ARIHANTACA.NS", "CADSYS.NS", "SAMBHAAV.NS", "DURLAX.NS", "CINEVISTA.NS", "GLOBALPET.NS", "BIOFILCHEM.NS", "ARSHIYA.NS", "MIEL.NS",
            "NEELAM.NS", "ORIENTLTD.NS", "DAMODARIND.NS", "SECMARK.NS", "ARVINDPORT.NS", "ABHAPOWER.NS", "MYMUDRA.NS", "21STCENMGM.NS", "MOKSH.NS", "ONYX.NS", "LCCINFOTEC.NS", "RILINFRA.NS", "DELTAMAGNT.NS", "SATIPOLY.NS", "SLONE.NS",
            "ASTRON.NS", "DIGJAMLMTD.NS", "UNILEX.NS", "BLBLIMITED.NS", "HISARMETAL.NS", "MHHL.NS", "SIMBHALS.NS", "GANGAFORGE.NS", "MEP.NS", "PRECISION.NS", "PROLIFE.NS", "MAL.NS", "GSMFOILS.NS", "DOLLEX.NS", "FORGEAUTO.NS",
            "AUROIMPEX.NS", "ATALREAL.NS", "SYNOPTICS.NS", "PPSL.NS", "WOL3D.NS", "PRANIK.NS", "CLOUD.NS", "SILKFLEX.NS", "AVSL.NS", "DIL.NS", "ARABIAN.NS", "MADHUCON.NS", "HBSL.NS", "PNC.NS", "HOVS.NS",
            "CELEBRITY.NS", "ARCHIES.NS", "SIDDHIKA.NS", "KONTOR.NS", "AGROPHOS.NS", "PATTECH.NS", "BABAFP.NS", "KARMAENG.NS", "LEXUS.NS", "MAHICKRA.NS", "SERVICE.NS", "PRESSTONIC.NS", "AGNI.NS", "CLSL.NS", "TREEHOUSE.NS",
            "PREMIUM.NS", "AKSHAR.NS", "SAJHOTELS.NS", "OMFURN.NS", "RADIOWALLA.NS", "AROGRANITE.NS", "SVPGLOB.NS", "DEEM.NS", "BULKCORP.NS", "KAVVERITEL.NS", "RELIABLE.NS", "AMEYA.NS", "AKIKO.NS", "MEDIORG.NS", "TRIDHYA.NS",
            "NIBL.NS", "ARISTO.NS", "3PLAND.NS", "PENTAGON.NS", "BMETRICS.NS", "QUICKTOUCH.NS", "SHIVAMILLS.NS", "CPS.NS", "BALKRISHNA.NS", "ROML.NS", "JFLLIFE.NS", "MBECL.NS", "BANG.NS", "MALUPAPER.NS", "SITINET.NS",
            "BANARBEADS.NS", "WEWIN.NS", "HRHNEXT.NS", "SANGANI.NS", "VISHWAS.NS", "MARSHALL.NS", "RCDL.NS", "MAGSON.NS", "KEEPLEARN.NS", "REXPIPES.NS", "VIAZ.NS", "MVKAGRO.NS", "VDEAL.NS", "JETFREIGHT.NS", "SEYAIND.NS",
            "FMNL.NS", "SHEETAL.NS", "SILGO.NS", "GOLDENTOBC.NS", "LFIC.NS", "AMBANIORGO.NS", "VERTEXPLUS.NS", "MILTON.NS", "MANUGRAPH.NS", "ORIENTALTL.NS", "RKDL.NS", "UMA.NS", "VSCL.NS", "SUPREMEENG.NS", "DNAMEDIA.NS",
            "ROLLT.NS", "YUDIZ.NS", "GSTL.NS", "UCL.NS", "SIGNORIA.NS", "ITALIANE.NS", "COMMITTED.NS", "AKG.NS", "JAIPURKURT.NS", "MONOPHARMA.NS", "PHOGLOBAL.NS", "BURNPUR.NS", "GODHA.NS", "ROLTA.NS", "VELS.NS",
            "QVCEL.NS", "MFML.NS", "AGARWALFT.NS", "ABMINTLLTD.NS", "TVVISION.NS", "AKASH.NS", "SPPPOLY.NS", "KTL.NS", "PEARLPOLY.NS", "UWCSL.NS", "AATMAJ.NS", "CELLPOINT.NS", "PARAMOUNT.NS", "DKEGL.NS", "WINNY.NS",
            "LRRPL.NS", "SUPERSPIN.NS", "ICDSLTD.NS", "LAXMICOT.NS", "VISAMAN.NS", "MICROPRO.NS", "KANANIIND.NS", "GTECJAINX.NS", "THESL.NS", "ASHOKAMET.NS", "ADL.NS", "KSHITIJPOL.NS", "ANKITMETAL.NS", "ISHAN.NS", "HOACFOODS.NS",
            "VINEETLAB.NS", "IDEALTECHO.NS", "KALANA.NS", "COUNCODOS.NS", "SRPL.NS", "TECHIN.NS", "NEXTMEDIA.NS", "AILIMITED.NS", "MEGAFLEX.NS", "SHRENIK.NS", "SONUINFRA.NS", "NARMADA.NS", "NGIL.NS", "BINANIIND.NS", "TAPIFRUIT.NS",
            "WALPAR.NS", "PODDARHOUS.NS", "AMBICAAGAR.NS", "SGL.NS", "TNTELE.NS", "PERFECT.NS", "MANDEEP.NS", "TIMESCAN.NS", "CONTI.NS", "SAGARDEEP.NS", "ADROITINFO.NS", "MADHAV.NS", "TARAPUR.NS", "JETKNIT.NS", "FLFL.NS",
            "KKVAPOW.NS", "LIBAS.NS", "ASLIND.NS", "KHANDSE.NS", "TGBHOTELS.NS", "MASKINVEST.NS", "TECILCHEM.NS", "ATLASCYCLE.NS", "GATECH.NS", "NIDAN.NS", "BIRDYS.NS", "ARSSINFRA.NS", "KRIDHANINF.NS", "KHAITANLTD.NS", "YCCL.NS",
            "GAJANAND.NS", "VERA.NS", "INSPIRE.NS", "CYBERMEDIA.NS", "MOHITIND.NS", "SANGINITA.NS", "BIKEWO.NS", "VIJIFIN.NS", "MORARJEE.NS", "SUMEETINDS.NS", "WILLAMAGOR.NS", "UNIINFO.NS", "VERITAAS.NS", "MITTAL.NS", "JIWANRAM.NS",
            "GLOBALE.NS", "HYBRIDFIN.NS", "MOXSH.NS", "HAVISHA.NS", "TIJARIA.NS", "NAGREEKCAP.NS", "SHANTHALA.NS", "BLUECHIP.NS", "KANDARP.NS", "MAKS.NS", "SPRL.NS", "CMRSL.NS", "FEL.NS", "SANWARIA.NS", "GOENKA.NS",
            "INFOMEDIA.NS", "POLYSIL.NS", "ACEINTEG.NS", "NKIND.NS", "DHTL.NS", "SUULD.NS", "KAUSHALYA.NS", "OLIL.NS", "GAYAHWS.NS", "AGUL.NS", "MARINETRAN.NS", "CBAZAAR.NS", "VIVIDHA.NS", "EXCELLENT.NS", "SABAR.NS",
            "MINDPOOL.NS", "CALSOFT.NS", "IMPEXFERRO.NS", "QFIL.NS", "FALCONTECH.NS", "RETAIL.NS", "HEADSUP.NS", "QUADPRO.NS", "EDUCOMP.NS", "GUJRAFFIA.NS", "VILINBIO.NS", "WINSOME.NS", "COMPINFO.NS", "ANTGRAPHIC.NS", "SHUBHLAXMI.NS",
            "BOSS.NS", "GFSTEELS.NS", "BALCO.NS", "SUNREST.NS", "PLADAINFO.NS", "MTEDUCARE.NS", "SECURCRED.NS", "ONELIFECAP.NS", "INDIFRA.NS", "SILLYMONKS.NS", "SAHAJ.NS", "AHIMSA.NS", "LYPSAGEMS.NS", "BOHRAIND.NS", "RADAAN.NS",
            "GLFL.NS", "SHYAMTEL.NS", "SAROJA.NS", "RICHA.NS", "NORBTEAEXP.NS", "UMESLTD.NS", "RITEZONE.NS", "NTL.NS", "SHANTI.NS", "TCIFINANCE.NS", "OMKARCHEM.NS", "MPTODAY.NS", "BRIGHT.NS", "TRANSWIND.NS", "ORTINGLOBE.NS",
            "ARENTERP.NS", "VCL.NS", "VIVO.NS", "AMJUMBO.NS", "ALPSINDUS.NS", "AMIABLE.NS", "MANAV.NS", "JAKHARIA.NS", "DCMFINSERV.NS", "CREATIVEYE.NS", "SABEVENTS.NS", "SMVD.NS", "BLUECOAST.NS", "DRL.NS", "PREMIER.NS",
            "NIRAJISPAT.NS", "UNIVAFOODS.NS", "EUROTEXIND.NS", "FSC.NS", "SETUINFRA.NS", "ACCORD.NS", "BKMINDST.NS", "CMICABLES.NS", "ITTL.NS", "JALAN.NS", "LAKPRE.NS", "MELSTAR.NS", "SANCO.NS", "ORTEL.NS", "BGLOBAL.NS",
            "QUINTEGRA.NS", "GANGOTRI.NS", "CMMIPL.NS", "VASA.NS", "RAJVIR.NS", "ABHISHEK.NS", "ABNINT.NS", "AHLWEST.NS", "AIFL.NS", "AJRINFRA.NS", "ALCHEM.NS", "ARCOTECH.NS", "ARTEDZ.NS", "ASIL.NS", "ATCOM.NS",
            "ATNINTER.NS", "BALLARPUR.NS", "BANSAL.NS", "BDR.NS", "BHALCHANDR.NS", "BHARATIDIL.NS", "BILENERGY.NS", "BLUEBLENDS.NS", "BRFL.NS", "CANDC.NS", "CKFSL.NS", "CURATECH.NS", "DHARSUGAR.NS", "DQE.NS", "DRSCARGO.NS",
            "DSKULKARNI.NS", "EASTSILK.NS", "EASUNREYRL.NS", "EON.NS", "EUROCERA.NS", "EUROMULTI.NS", "FEDDERELEC.NS", "FIVECORE.NS", "GBGLOBAL.NS", "GIRRESORTS.NS", "GITANJALI.NS", "ICSA.NS", "INDLMETER.NS", "INDOSOLAR.NS", "INDUSFILA.NS",
            "IVRCLINFRA.NS", "JAINSTUDIO.NS", "JBFIND.NS", "JPINFRATEC.NS", "KALYANI.NS", "KGL.NS", "KSERASERA.NS", "KSK.NS", "KUNDANMM.NS", "LAKSHMIEFL.NS", "LEEL.NS", "MANPASAND.NS", "MCDHOLDING.NS", "MERCATOR.NS", "METALFORGE.NS",
            "METKORE.NS", "MVL.NS", "NAKODA.NS", "NITINFIRE.NS", "NUTEK.NS", "OPAL.NS", "OPTOCIRCUI.NS", "PDPL.NS", "PENTAGOLD.NS", "PINCON.NS", "PRATIBHA.NS", "PUNJLLOYD.NS", "RAINBOWPAP.NS", "RELCAPITAL.NS", "RMCL.NS",
            "RMMIL.NS", "RNAVAL.NS", "RUSHABEAR.NS", "SATHAISPAT.NS", "SHAIVAL.NS", "SHIRPUR-G.NS", "SIIL.NS", "SKSTEXTILE.NS", "SPENTEX.NS", "SPTL.NS", "SRIRAM.NS", "SSINFRA.NS", "TALWALKARS.NS", "TALWGYM.NS", "TECHNOFAB.NS",
            "TULSI.NS", "UNIPLY.NS", "UNITY.NS", "VALECHAENG.NS", "VALUEIND.NS", "VIDEOIND.NS", "VISUINTL.NS", "VIVIMEDLAB.NS", "ZICOM.NS"
        ]
        
        # Remove duplicates and sort
        all_nse_stocks = sorted(list(set(all_nse_stocks)))
        
        # Create DataFrame with both symbol and name columns
        stocks_data = []
        for symbol in all_nse_stocks:
            name = symbol.replace('.NS', '')
            stocks_data.append({'symbol': symbol, 'name': name})
        
        stocks_df = pd.DataFrame(stocks_data)
        
        # Save to CSV
        stocks_df.to_csv(STOCKS_FILE, index=False)
        st.success(f"✅ Loaded {len(stocks_df)} NSE stocks")
        print(f"✅ Loaded {len(stocks_df)} NSE stocks")
        
        return stocks_df

    def load_strategies(self) -> Dict:
        """Load all strategy JSON files"""
        strategies = {}
        self.create_default_strategies()
        
        for filename in os.listdir(STRATEGIES_DIR):
            if filename.endswith('.json'):
                strategy_name = filename[:-5]
                try:
                    with open(os.path.join(STRATEGIES_DIR, filename), 'r') as f:
                        strategies[strategy_name] = json.load(f)
                except json.JSONDecodeError:
                    st.error(f"Error reading strategy file: {filename}. It might be corrupted.")
        print(f"✅ Loaded {len(strategies)} strategies")
        return strategies

    def create_default_strategies(self):
        """Create default strategies with the new, more powerful format."""
        # This strategy mimics the one from your screenshot
        swing_booster = {
            "name": "Swing Booster (Chartink-like)",
            "description": "A complex multi-timeframe WMA strategy.",
            "conditions": [
                {
                    "lhs": {"type": "indicator", "name": "wma", "params": {"period": 1}, "timeframe": "daily", "offset": 0},
                    "operator": ">",
                    "rhs": {"type": "indicator", "name": "wma", "params": {"period": 2}, "timeframe": "monthly", "offset": 1}
                },
                {
                    "lhs": {"type": "indicator", "name": "close", "params": {}, "timeframe": "daily", "offset": 0},
                    "operator": ">",
                    "rhs": {"type": "value", "value": 20}
                },
                {
                    "lhs": {"type": "indicator", "name": "close", "params": {}, "timeframe": "daily", "offset": 0},
                    "operator": "<=",
                    "rhs": {"type": "value", "value": 400}
                }
            ]
        }

        # This strategy uses some of the new indicators
        momentum_gain = {
            "name": "Momentum Gain",
            "description": "RSI and EMA-based momentum strategy.",
            "conditions": [
                {
                    "lhs": {"type": "indicator", "name": "rsi", "params": {"period": 14}, "timeframe": "daily", "offset": 0},
                    "operator": ">",
                    "rhs": {"type": "value", "value": 60}
                },
                {
                    "lhs": {"type": "indicator", "name": "close", "params": {}, "timeframe": "daily", "offset": 0},
                    "operator": ">",
                    "rhs": {"type": "indicator", "name": "ema", "params": {"period": 50}, "timeframe": "daily", "offset": 0}
                },
                {
                    "lhs": {"type": "indicator", "name": "volume_turnover", "params": {}, "timeframe": "daily", "offset": 0},
                    "operator": ">",
                    "rhs": {"type": "value", "value": 10000000}
                }
            ]
        }

        strategies_to_create = [
            ("swing_booster_new", swing_booster),
            ("momentum_gain", momentum_gain)
        ]
        
        for filename, strategy in strategies_to_create:
            filepath = os.path.join(STRATEGIES_DIR, f"{filename}.json")
            if not os.path.exists(filepath):
                with open(filepath, 'w') as f:
                    json.dump(strategy, f, indent=2)

    def get_stock_data(self, symbol: str, period: str = "2y") -> Optional[pd.DataFrame]:
        """Fetch stock data with caching. Falls back to cache if Yahoo Finance fails."""
        cache_file = os.path.join(CACHE_DIR, f"{symbol.replace('.NS', '')}.csv")
        
        # Helper function to load from cache
        def load_from_cache():
            if os.path.exists(cache_file):
                try:
                    return pd.read_csv(cache_file, parse_dates=['Date'], index_col='Date')
                except Exception:
                    pass
            return None
        
        # Check if we have a fresh cache (less than 24 hours old)
        if os.path.exists(cache_file):
            cache_time = os.path.getmtime(cache_file)
            if time.time() - cache_time < 86400:  # 24 hours
                cached_data = load_from_cache()
                if cached_data is not None:
                    return cached_data
        
        # Try to fetch from Yahoo Finance
        try:
            data = yf.download(symbol, period=period, progress=False, auto_adjust=True)
            if not data.empty:
                # Handle potential MultiIndex columns by taking the first level.
                if isinstance(data.columns, pd.MultiIndex):
                    data.columns = data.columns.get_level_values(0)

                # Standardize column names to PascalCase (e.g., 'open' -> 'Open').
                data.columns = [str(col).capitalize() for col in data.columns]
                
                data.to_csv(cache_file)
                return data
        except Exception as e:
            # Yahoo Finance failed, will fall back to cache
            pass
        
        # Fall back to cached data (even if older than 24 hours)
        cached_data = load_from_cache()
        if cached_data is not None:
            return cached_data
        
        # No data available at all
        print(f"❌ No data available for {symbol} (Yahoo failed and no cache)")
        return None

    def _calculate_single_indicator(self, df: pd.DataFrame, name: str, params: Dict) -> Optional[pd.Series]:
        """Calculates a single indicator on demand based on its name and parameters."""
        p = params.get('period', 14) # Default period if not specified
        p2 = params.get('period_fast', 12)
        p3 = params.get('period_slow', 26)
        p4 = params.get('period_signal', 9)

        # Base values
        if name == 'close': return df['Close']
        if name == 'open': return df['Open']
        if name == 'high': return df['High']
        if name == 'low': return df['Low']
        if name == 'volume': return df['Volume']

        # Moving Averages
        if name == 'sma': return ta.trend.SMAIndicator(df['Close'], window=p).sma_indicator()
        if name == 'ema': return ta.trend.EMAIndicator(df['Close'], window=p).ema_indicator()
        if name == 'wma': return ta.trend.WMAIndicator(df['Close'], window=p).wma()
        # Note: ta library doesn't have a direct HMA. WMA is used as a placeholder.
        # For a true HMA, a more complex custom function would be needed.
        if name == 'hma': return ta.trend.WMAIndicator(df['Close'], window=p).wma()
        if name == 'vwma': return ta.volume.VolumeWeightedAveragePrice(high=df['High'], low=df['Low'], close=df['Close'], volume=df['Volume'], window=p).volume_weighted_average_price()
        
        # Momentum & Trend
        if name == 'rsi': return ta.momentum.RSIIndicator(df['Close'], window=p).rsi()
        if name == 'macd': return ta.trend.MACD(df['Close'], window_slow=p3, window_fast=p2, window_sign=p4).macd()
        if name == 'macd_signal': return ta.trend.MACD(df['Close'], window_slow=p3, window_fast=p2, window_sign=p4).macd_signal()
        if name == 'adx': return ta.trend.ADXIndicator(df['High'], df['Low'], df['Close'], window=p).adx()
        
        # Volatility & Volume
        if name == 'atr': return ta.volatility.AverageTrueRange(df['High'], df['Low'], df['Close'], window=p).average_true_range()
        if name == 'atr_ratio': return ta.volatility.AverageTrueRange(df['High'], df['Low'], df['Close'], window=p).average_true_range() / df['Close']
        if name == 'bb_high': return ta.volatility.BollingerBands(df['Close'], window=p).bollinger_hband()
        if name == 'bb_low': return ta.volatility.BollingerBands(df['Close'], window=p).bollinger_lband()
        if name == 'bb_mid': return ta.volatility.BollingerBands(df['Close'], window=p).bollinger_mavg()
        if name == 'volume_turnover': return df['Volume'] * df['Close']
        if name == 'volume_sma': return ta.trend.SMAIndicator(df['Volume'], window=p).sma_indicator()

        print(f"❌ Unknown indicator: {name}")
        return None # Indicator not found

    def _resolve_operand(self, data_cache: Dict, operand: Dict) -> float:
        """Resolves an operand (LHS or RHS) to a single float value."""
        if operand['type'] == 'value':
            return float(operand['value'])
        
        if operand['type'] == 'indicator':
            tf = operand['timeframe']
            name = operand['name']
            params = operand.get('params', {})
            offset = operand.get('offset', 0)

            df = data_cache[tf]
            if df is None or len(df) <= offset:
                raise ValueError(f"Not enough data for timeframe '{tf}' at offset {offset}")
            
            param_str = "_".join(f"{k}{v}" for k, v in sorted(params.items()))
            col_name = f"{name}_{param_str}" if params else name

            if col_name not in df.columns:
                indicator_series = self._calculate_single_indicator(df, name, params)
                if indicator_series is None:
                    raise ValueError(f"Unknown indicator '{name}'")
                df[col_name] = indicator_series
            
            value = df[col_name].iloc[-(1 + offset)]
            if pd.isna(value):
                raise ValueError(f"Indicator '{col_name}' is NaN at offset {offset}")
            print(f"✅ Resolved indicator '{col_name}' with params {params} at offset {offset} to value {value}")
            return value

        raise TypeError(f"Unknown operand type: {operand['type']}")

    def _compare(self, val1: float, operator: str, val2: float, tolerance: Optional[float] = None) -> bool:
        """Performs comparison between two values, with tolerance support for '≈'."""
        if operator == '>': return val1 > val2
        if operator == '<': return val1 < val2
        if operator == '>=': return val1 >= val2
        if operator == '<=': return val1 <= val2
        if operator == '==': return val1 == val2
        if operator == '≈ (approx)':
            if tolerance is None or val2 == 0:
                print(f"❌ Tolerance not specified or division by zero risk for comparison: {val1} ≈ {val2}")
                # Fallback to float equality if no tolerance or div by zero risk
                return abs(val1 - val2) < 1e-9
            print(f"✅ Comparing {val1} ≈ {val2} with tolerance {tolerance}%")
            # Check if val1 is within val2 ± tolerance%
            return abs(val1 - val2) <= abs(val2 * (tolerance / 100.0))
        return False

    def evaluate_strategy(self, data_daily: pd.DataFrame, strategy: Dict) -> bool:
        """New evaluation engine for complex strategies."""
        if data_daily is None or len(data_daily) < 50:
            print("❌ Not enough data to evaluate strategy")
            return False

        try:
            # Prepare data cache with daily, weekly, and monthly data
            data_cache = {'daily': data_daily.copy()}
            data_cache['weekly'] = data_daily.resample('W-FRI').agg({
                'Open': 'first', 'High': 'max', 'Low': 'min', 'Close': 'last', 'Volume': 'sum'
            }).dropna()
            data_cache['monthly'] = data_daily.resample('M').agg({
                'Open': 'first', 'High': 'max', 'Low': 'min', 'Close': 'last', 'Volume': 'sum'
            }).dropna()

            for condition in strategy.get('conditions', []):
                if 'lhs' not in condition or 'rhs' not in condition:
                    return False
                
                # Resolve the Left-Hand Side value
                lhs_val = self._resolve_operand(data_cache, condition['lhs'])
                
                # Resolve the Right-Hand Side base value
                rhs_operand = condition['rhs']
                rhs_val = self._resolve_operand(data_cache, rhs_operand)
                
                # If RHS is an indicator, apply multiplier and/or additive offset
                if rhs_operand.get('type') == 'indicator':
                    multiplier = rhs_operand.get('multiplier', 1.0)
                    add_offset = rhs_operand.get('add_offset', 0.0)
                    rhs_val = (rhs_val * multiplier) + add_offset

                # Perform the final comparison
                if not self._compare(lhs_val, condition['operator'], rhs_val, condition.get('tolerance')):
                    print(f"❌ Condition failed: {lhs_val} {condition['operator']} {rhs_val} (LHS: {condition['lhs']}, RHS: {condition['rhs']})")
                    return False
            print(f"✅ Strategy '{strategy['name']}' passed all conditions")
            return True # All conditions passed
        except (ValueError, TypeError, IndexError, KeyError) as e:
            print(f"❌ Error evaluating strategy '{strategy['name']}': {e}")
            # Silently fail for stocks that don't have enough data or have other issues
            return False
    
    def screen_stocks(self, strategy_name: str, max_stocks: int = 2000, price_min: float = 0, price_max: float = 10000) -> List[Dict]:
        """Screen all stocks using the new evaluation engine."""
        if strategy_name not in self.strategies:
            print(f"❌ Strategy '{strategy_name}' not found")
            return []

        strategy = self.strategies[strategy_name]
        results = []
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        stocks_to_screen = self.stocks_df.head(max_stocks)
        total_stocks = len(stocks_to_screen)
        processed_count = 0

        for i, stock_row in stocks_to_screen.iterrows():
            progress = (i + 1) / total_stocks
            progress_bar.progress(progress)
            
            symbol = stock_row['symbol']
            name = stock_row['name']
            
            status_text.text(f"Screening {symbol} ({i+1}/{total_stocks}) | Found: {len(results)}")
            
            data = self.get_stock_data(symbol)
            
            if data is not None and not data.empty:
                # This retrieves the last row's 'Close' data. It might be a single
                # number (scalar) or a Series if there are duplicate 'Close' columns.
                price_data = data['Close'].iloc[-1]
                
                # Robustly handle both cases to get a single float value
                if isinstance(price_data, pd.Series):
                    current_price = price_data.iloc[0] # Take the value from the first 'Close' column
                else:
                    current_price = price_data # It's already a single value
                    
                if price_min <= current_price <= price_max:
                    # DEBUG: Log first 5 stocks being evaluated
                    if i < 5:
                        print(f"🔍 DEBUG [{symbol}]: Price={current_price}, evaluating strategy...")
                    
                    strategy_passed = self.evaluate_strategy(data, strategy)
                    
                    if i < 5:
                        print(f"🔍 DEBUG [{symbol}]: Strategy result = {strategy_passed}")
                    
                    if strategy_passed:
                        latest = data.iloc[-1]

                        # --- START OF CHANGE ---
                        # Calculate percentage change
                        if len(data) >= 2:
                            previous_close = data['Close'].iloc[-2]
                            pct_change = ((current_price - previous_close) / previous_close) * 100 if previous_close > 0 else 0.0
                        else:
                            pct_change = 0.0 # Not enough data to calculate change

                        results.append({
                            'Symbol': symbol,
                            'Name': name,
                            'TradingView': f"https://in.tradingview.com/chart/?symbol=NSE:{name}",
                            '%Chg': round(pct_change, 2),
                            'Price': round(current_price, 2),
                            'Volume': int(latest['Volume'])
                        })
                        # --- END OF CHANGE ---
            processed_count += 1
            
        progress_bar.empty()
        status_text.empty()
        st.info(f"📈 Processed {processed_count} stocks | ✅ Found {len(results)} matches")
        print(f"📈 Processed {processed_count} stocks | ✅ Found {len(results)} matches")
        return results

# ==============================================================================
# Global Helper for Displaying Conditions
# ==============================================================================
def format_condition_as_html(cond: Dict) -> str:
    """Formats a single strategy condition object into a human-readable HTML string."""
    
    def format_operand(op: Dict) -> str:
        if op.get('type') == 'value':
            return f"<span style='color: #ffaa00; font-weight: bold;'>{op.get('value', 'N/A')}</span>"
        
        if op.get('type') != 'indicator':
            return "<span style='color:red;'>[Invalid Operand]</span>"
        
        name = op.get('name', 'N/A')
        display_name = name.replace('_', ' ').title()
        if name == 'atr_ratio':
            display_name = 'ATR / Close'
        elif name.endswith('_sma'):
            display_name = name.replace('_', ' ').upper()

        params = op.get('params', {})
        p_str = f"({params.get('period', '')})" if params else ""
        o_str = f" [{op.get('offset', 0)} ago]" if op.get('offset', 0) > 0 else ""
        
        # Base indicator string
        label = f"<span style='color: #90ee90;'>{op.get('timeframe', 'N/A').capitalize()} {display_name}{p_str}{o_str}</span>"
        
        # Prepend multiplier if it exists and is not 1
        multiplier = op.get('multiplier', 1.0)
        if multiplier != 1.0:
            label = f"<span style='color: #ffaa00;'>{multiplier}</span> × " + label

        # Append additive offset if it exists and is not 0
        add_offset = op.get('add_offset', 0.0)
        if add_offset != 0.0:
            sign = "+" if add_offset > 0 else "-"
            label += f" {sign} <span style='color: #ffaa00; font-weight: bold;'>{abs(add_offset)}</span>"

        print(f"✅ Formatted operand: {label}")
        # Return the formatted label
        return label

    if 'lhs' not in cond or 'rhs' not in cond:
        print("❌ Invalid condition format: missing 'lhs' or 'rhs'")
        return "Invalid condition format"
    
    lhs_str = format_operand(cond['lhs'])
    rhs_str = format_operand(cond['rhs'])
    
    op_str_val = cond.get('operator', '?')
    op_str_extra = ""
    if op_str_val == '≈ (approx)' and 'tolerance' in cond:
        op_str_extra = f" (±{cond['tolerance']}%)"
        
    op_str = f"<span style='color: #ff4b4b; font-weight: bold;'>{op_str_val}</span>{op_str_extra}"

    print(f"✅ Formatted condition: {lhs_str} {op_str} {rhs_str}")
    # Return the full formatted condition string
    return f"{lhs_str} {op_str} {rhs_str}"

# ==============================================================================
# ✅ CHANGE: The entire create_strategy_editor function is updated for better UX.
# ==============================================================================
def create_strategy_editor():
    """A powerful UI for creating complex, multi-timeframe strategies."""
    st.header("📝 Strategy Editor")

    # List of available indicators for the UI
    INDICATOR_LIST = [
        "close", "open", "high", "low", "volume", "volume_sma", "volume_turnover",
        "sma", "ema", "wma", "hma", "vwma", "rsi", "macd", "macd_signal", "adx",
        "atr", "bb_high", "bb_mid", "bb_low"
    ]
    # Indicators that require a 'period' parameter
    NEEDS_PERIOD = [
        "volume_sma", "sma", "ema", "wma", "hma", "vwma", "rsi", "adx", "atr",
        "bb_high", "bb_mid", "bb_low"
    ]

    # Initialize session state for conditions list and a unique form identifier
    if 'conditions' not in st.session_state:
        st.session_state.conditions = []
    if 'form_id' not in st.session_state:
        st.session_state.form_id = 0

    st.subheader("1. Add New Condition")
    
    # Placeholder for success messages
    message_container = st.empty()

    # Form to add a new condition
    with st.container():
        # Use the form_id to create unique keys for widgets, allowing the form to "reset"
        form_key = st.session_state.form_id
        
        c1, c2, c3 = st.columns([5, 2, 5])
        
        with c1:
            st.markdown("**LHS (Indicator)**")
            lhs_timeframe = st.selectbox("Timeframe", ["daily", "weekly", "monthly"], key=f"lhs_tf_{form_key}")
            lhs_indicator = st.selectbox("Indicator", INDICATOR_LIST, key=f"lhs_ind_{form_key}")
            
            lhs_indicator_name = lhs_indicator
            if lhs_indicator == 'atr':
                if st.checkbox("Normalize (ATR / Close)", key=f"lhs_atr_norm_{form_key}"):
                    lhs_indicator_name = 'atr_ratio'

            lhs_params = {}
            if lhs_indicator in NEEDS_PERIOD:
                lhs_params['period'] = st.number_input("Period", min_value=1, value=20, step=1, key=f"lhs_period_{form_key}")
            lhs_offset = st.number_input("Offset (periods ago)", min_value=0, value=0, step=1, key=f"lhs_offset_{form_key}")

        with c2:
            st.markdown("**Operator**")
            operator = st.selectbox("Compare", [">", "<", ">=", "<=", "==", "≈ (approx)"], label_visibility="collapsed", key=f"op_{form_key}")

        with c3:
            st.markdown("**RHS (Compare To)**")
            rhs_type = st.radio("Type", ["Value", "Indicator"], horizontal=True, key=f"rhs_type_{form_key}")
            
            if rhs_type == "Value":
                rhs_value = st.number_input("Value", value=0.0, step=1.0, key=f"rhs_val_{form_key}", label_visibility="collapsed")
                rhs_obj = {"type": "value", "value": rhs_value}
            else: # rhs_type == "Indicator"
                rhs_timeframe = st.selectbox("Timeframe", ["daily", "weekly", "monthly"], key=f"rhs_tf_{form_key}")
                rhs_indicator = st.selectbox("Indicator", INDICATOR_LIST, key=f"rhs_ind_{form_key}")
                
                rhs_indicator_name = rhs_indicator
                if rhs_indicator == 'atr':
                    if st.checkbox("Normalize (ATR / Close)", key=f"rhs_atr_norm_{form_key}"):
                        rhs_indicator_name = 'atr_ratio'

                rhs_params = {}
                if rhs_indicator in NEEDS_PERIOD:
                    rhs_params['period'] = st.number_input("Period", min_value=1, value=20, step=1, key=f"rhs_period_{form_key}")
                
                rhs_offset = st.number_input("Offset (periods ago)", min_value=0, value=0, step=1, key=f"rhs_offset_{form_key}")
                rhs_multiplier = st.number_input("Multiplier", min_value=0.0, value=1.0, step=0.01, key=f"rhs_multiplier_{form_key}")
                rhs_add_offset = st.number_input("Add Number", min_value=-10000.0, value=0.0, step=0.1, key=f"rhs_add_offset_{form_key}", help="Adds a fixed number to the RHS indicator value after multiplying.")

                rhs_obj = {"type": "indicator", "name": rhs_indicator_name, "timeframe": rhs_timeframe, "offset": rhs_offset}
                if rhs_params: rhs_obj["params"] = rhs_params
                if rhs_multiplier != 1.0: rhs_obj["multiplier"] = rhs_multiplier
                if rhs_add_offset != 0.0: rhs_obj["add_offset"] = rhs_add_offset

        # Add Tolerance field conditionally
        tolerance_pct = 0.0
        if operator == "≈ (approx)":
            tolerance_pct = st.number_input("Tolerance (%)", min_value=0.0, value=1.0, step=0.1, key=f"tolerance_pct_{form_key}", help="e.g., 1.0 means the LHS value can be within ±1% of the RHS value.")

        # Construct full condition object for preview and for saving
        lhs_obj = {"type": "indicator", "name": lhs_indicator_name, "timeframe": lhs_timeframe, "offset": lhs_offset}
        if lhs_params: lhs_obj["params"] = lhs_params
        
        full_condition = {"lhs": lhs_obj, "operator": operator, "rhs": rhs_obj}
        if operator == "≈ (approx)" and tolerance_pct > 0:
            full_condition["tolerance"] = tolerance_pct

        st.markdown("---")
        st.markdown("**Preview:**")
        st.markdown(f"> {format_condition_as_html(full_condition)}", unsafe_allow_html=True)
        
        st.markdown("---")
        if st.button("➕ Add Condition", type="primary", use_container_width=True):
            st.session_state.conditions.append(full_condition)
            # Incrementing the form_id will cause all widgets above to get new keys, thus resetting them
            st.session_state.form_id += 1
            message_container.success(f"Condition #{len(st.session_state.conditions)} added! You can now define the next one.")
            print(f"✅ Condition #{len(st.session_state.conditions)} added: {full_condition}")
            st.rerun()

    # --- Display current conditions ---
    if st.session_state.conditions:
        st.markdown("---")
        st.subheader("2. Current Conditions in Strategy")
        for i, cond in enumerate(st.session_state.conditions):
            col1, col2 = st.columns([5, 1])
            with col1:
                st.markdown(f"**{i+1}.** {format_condition_as_html(cond)}", unsafe_allow_html=True)
            with col2:
                if st.button("Remove", key=f"remove_{i}", use_container_width=True):
                    st.session_state.conditions.pop(i)
                    # Clear any "Condition Added" messages and rerun
                    message_container.empty()
                    print(f"✅ Condition #{i+1} removed")   
                    st.rerun()

    # --- Save Strategy Form ---
    if st.session_state.conditions:
        st.markdown("---")
        st.subheader("3. Save Your Strategy")
        with st.form("save_strategy_form"):
            strategy_name = st.text_input("Strategy Name", placeholder="e.g., My Multi-WMA Strategy")
            strategy_desc = st.text_area("Description", placeholder="A series of chained WMA and price conditions.")
            
            submitted = st.form_submit_button("💾 Save Strategy")
            if submitted:
                if not strategy_name:
                    st.error("❗ Strategy Name is required.")
                else:
                    new_strategy = {
                        "name": strategy_name,
                        "description": strategy_desc,
                        "conditions": st.session_state.conditions
                    }
                    
                    filename = "".join(c for c in strategy_name if c.isalnum() or c in ' _').rstrip().lower().replace(" ", "_")
                    filepath = os.path.join(STRATEGIES_DIR, f"{filename}.json")
                    
                    with open(filepath, 'w') as f:
                        json.dump(new_strategy, f, indent=2)
                    
                    # Reset the editor
                    st.session_state.conditions = []
                    st.session_state.form_id += 1 
                    
                    st.success(f"✅ Strategy '{strategy_name}' saved successfully!")
                    st.balloons()
                    time.sleep(1)
                    print(f"✅ Strategy '{strategy_name}' saved to {filepath}")
                    st.rerun()


# ==============================================================================
# AI STRATEGY BUILDER - Natural Language to JSON Conversion
# ==============================================================================
def create_ai_strategy_builder(screener):
    """AI-powered strategy builder using Ollama for natural language conversion."""
    st.header("🤖 AI Strategy Builder")
    st.caption("Convert natural language descriptions or strategy documents into executable screening strategies using local AI.")
    
    # Try to import OllamaClient
    try:
        from ollama_client import OllamaClient, extract_text_from_file
        ollama_available = True
    except ImportError as e:
        ollama_available = False
        st.error(f"❌ Ollama client module not found: {e}")
        st.info("Please ensure ollama_client.py is in the same directory.")
        return
    
    # Initialize session state for AI builder
    if 'ai_generated_strategy' not in st.session_state:
        st.session_state.ai_generated_strategy = None
    if 'ai_explanation' not in st.session_state:
        st.session_state.ai_explanation = None
    if 'ai_error' not in st.session_state:
        st.session_state.ai_error = None
    if 'ollama_client' not in st.session_state:
        st.session_state.ollama_client = None
    
    # Ollama connection section
    with st.expander("⚙️ Ollama Configuration", expanded=True):
        col1, col2 = st.columns([2, 1])
        
        with col1:
            available_models = []
            try:
                temp_client = OllamaClient()
                available_models = temp_client.get_available_models()
            except:
                pass
            
            if available_models:
                model_options = available_models
            else:
                model_options = ["mistral:7b-instruct", "mistral", "llama2", "codellama", "llama3"]
            
            selected_model = st.selectbox(
                "Select Model",
                model_options,
                index=0,
                help="Choose the Ollama model for strategy conversion"
            )
        
        with col2:
            col2a, col2b = st.columns(2)
            with col2a:
                if st.button("🔗 Connect", use_container_width=True):
                    with st.spinner("Connecting to Ollama..."):
                        client = OllamaClient(model=selected_model)
                        is_available, message = client.is_available()
                        
                        if is_available:
                            st.session_state.ollama_client = client
                            st.success("✅ Connected!")
                        else:
                            st.session_state.ollama_client = None
                            st.error(f"❌ {message}")
            
            with col2b:
                warmup_disabled = st.session_state.ollama_client is None
                if st.button("🔥 Load Model", use_container_width=True, disabled=warmup_disabled, 
                            help="Pre-load the model into memory for faster responses"):
                    if st.session_state.ollama_client:
                        with st.spinner("⏳ Loading model into memory (this may take 1-3 minutes on first run)..."):
                            success, message = st.session_state.ollama_client.warmup_model()
                            if success:
                                st.success(f"✅ {message}")
                            else:
                                st.error(f"❌ {message}")
        
        # Show connection status
        if st.session_state.ollama_client:
            st.success(f"🟢 Connected to Ollama using model: **{st.session_state.ollama_client.model}**")
            st.info("💡 **Tip**: Click 'Load Model' first to pre-load the model. The first request may take 1-3 minutes if the model isn't loaded.")
        else:
            st.warning("🟡 Not connected to Ollama. Click 'Connect' to establish connection.")
            st.info("💡 Make sure Ollama is running: `ollama serve`")
    
    st.markdown("---")
    
    # Input mode selection
    input_mode = st.radio(
        "Choose Input Method",
        ["📝 Natural Language", "📄 Upload Document"],
        horizontal=True
    )
    
    if input_mode == "📝 Natural Language":
        # Natural Language Input
        st.subheader("Describe Your Strategy")
        
        # Example prompts
        with st.expander("💡 Example prompts"):
            st.markdown("""
            - "Find stocks with RSI below 30 and rising volume over last 5 days"
            - "Stocks trading above 200 EMA with strong ADX above 25"
            - "Golden cross stocks with price between 100 and 500"
            - "Weekly breakout above Bollinger upper band with 2x volume"
            - "Oversold mid-cap stocks with bullish MACD crossover"
            """)
        
        nl_input = st.text_area(
            "Enter your strategy description:",
            placeholder="e.g., Find profitable mid-cap stocks with RSI less than 30 and rising volume of last 5 days",
            height=120,
            key="nl_input"
        )
        
        generate_btn = st.button("🚀 Generate Strategy", type="primary", use_container_width=True, 
                                  disabled=not st.session_state.ollama_client)
        
        if generate_btn and nl_input.strip():
            if not st.session_state.ollama_client:
                st.error("Please connect to Ollama first!")
            else:
                with st.spinner("🤖 AI is analyzing your request..."):
                    success, strategy, explanation, error = st.session_state.ollama_client.parse_strategy_from_nl(nl_input)
                    
                    if success:
                        st.session_state.ai_generated_strategy = strategy
                        st.session_state.ai_explanation = explanation
                        st.session_state.ai_error = None
                        
                        # Add metadata
                        st.session_state.ai_generated_strategy['_metadata'] = {
                            'created_at': datetime.now().isoformat(),
                            'source': 'nl_conversion',
                            'original_query': nl_input,
                            'model_used': st.session_state.ollama_client.model
                        }
                    else:
                        st.session_state.ai_generated_strategy = None
                        st.session_state.ai_explanation = None
                        st.session_state.ai_error = error
    
    else:  # Document Upload
        st.subheader("Upload Strategy Document")
        
        uploaded_file = st.file_uploader(
            "Upload a document containing strategy description",
            type=['txt', 'pdf', 'docx'],
            help="Supported formats: TXT, PDF, DOCX"
        )
        
        if uploaded_file:
            # Save temporarily and extract text
            temp_path = os.path.join(CACHE_DIR, f"temp_{uploaded_file.name}")
            
            with open(temp_path, 'wb') as f:
                f.write(uploaded_file.getbuffer())
            
            try:
                document_text = extract_text_from_file(temp_path)
                
                with st.expander("📄 Extracted Text Preview", expanded=False):
                    st.text_area("Document content:", document_text[:2000] + ("..." if len(document_text) > 2000 else ""), height=200, disabled=True)
                
                if st.button("🚀 Generate Strategy from Document", type="primary", use_container_width=True,
                             disabled=not st.session_state.ollama_client):
                    if not st.session_state.ollama_client:
                        st.error("Please connect to Ollama first!")
                    else:
                        with st.spinner("🤖 AI is analyzing the document..."):
                            success, strategies, explanations, error = st.session_state.ollama_client.parse_strategy_from_document(document_text)
                            
                            if success and strategies:
                                st.session_state.ai_generated_strategy = strategies[0]
                                st.session_state.ai_explanation = explanations[0] if explanations else ""
                                st.session_state.ai_error = None
                                
                                # Add metadata
                                st.session_state.ai_generated_strategy['_metadata'] = {
                                    'created_at': datetime.now().isoformat(),
                                    'source': 'document_upload',
                                    'original_filename': uploaded_file.name,
                                    'model_used': st.session_state.ollama_client.model
                                }
                            else:
                                st.session_state.ai_generated_strategy = None
                                st.session_state.ai_explanation = None
                                st.session_state.ai_error = error
                
            except Exception as e:
                st.error(f"Error processing document: {str(e)}")
            finally:
                # Clean up temp file
                if os.path.exists(temp_path):
                    try:
                        os.remove(temp_path)
                    except:
                        pass
    
    # Display error if any
    if st.session_state.ai_error:
        st.error(f"❌ Error: {st.session_state.ai_error}")
        st.info("💡 Try rephrasing your request or check if Ollama is running.")
    
    # Display generated strategy
    if st.session_state.ai_generated_strategy:
        st.markdown("---")
        st.subheader("📋 Generated Strategy")
        
        strategy = st.session_state.ai_generated_strategy
        
        # Display name and description
        st.markdown(f"### {strategy.get('name', 'Unnamed Strategy')}")
        st.caption(strategy.get('description', ''))
        
        # Display conditions
        with st.expander("🔍 Strategy Conditions", expanded=True):
            for i, cond in enumerate(strategy.get('conditions', []), 1):
                if 'lhs' in cond and 'rhs' in cond:
                    st.markdown(f"**{i}.** {format_condition_as_html(cond)}", unsafe_allow_html=True)
        
        # JSON Preview with edit capability
        with st.expander("📝 JSON Preview (Editable)", expanded=False):
            # Remove metadata for display
            display_strategy = {k: v for k, v in strategy.items() if not k.startswith('_')}
            json_str = json.dumps(display_strategy, indent=2)
            
            edited_json = st.text_area(
                "Edit JSON if needed:",
                json_str,
                height=300,
                key="json_editor"
            )
            
            if st.button("✅ Apply Edits"):
                try:
                    edited_strategy = json.loads(edited_json)
                    # Re-add metadata
                    edited_strategy['_metadata'] = strategy.get('_metadata', {})
                    st.session_state.ai_generated_strategy = edited_strategy
                    st.success("Changes applied!")
                    st.rerun()
                except json.JSONDecodeError as e:
                    st.error(f"Invalid JSON: {e}")
        
        # AI Explanation
        if st.session_state.ai_explanation:
            with st.expander("💡 AI Explanation", expanded=True):
                st.markdown(st.session_state.ai_explanation)
        
        st.markdown("---")
        
        # Save options
        col1, col2, col3 = st.columns(3)
        
        with col1:
            strategy_name_input = st.text_input(
                "Strategy Name",
                value=strategy.get('name', 'AI Generated Strategy'),
                key="ai_save_name"
            )
        
        with col2:
            if st.button("💾 Save Strategy", type="primary", use_container_width=True):
                if strategy_name_input:
                    # Update name
                    save_strategy = st.session_state.ai_generated_strategy.copy()
                    save_strategy['name'] = strategy_name_input
                    
                    # Add AI explanation to metadata
                    if '_metadata' in save_strategy and st.session_state.ai_explanation:
                        save_strategy['_metadata']['ai_explanation'] = st.session_state.ai_explanation
                    
                    # Save to file
                    filename = "".join(c for c in strategy_name_input if c.isalnum() or c in ' _').rstrip().lower().replace(" ", "_")
                    filepath = os.path.join(STRATEGIES_DIR, f"{filename}.json")
                    
                    with open(filepath, 'w') as f:
                        json.dump(save_strategy, f, indent=2)
                    
                    st.success(f"✅ Strategy saved as '{strategy_name_input}'!")
                    st.balloons()
                    
                    # Clear state and reload
                    st.session_state.ai_generated_strategy = None
                    st.session_state.ai_explanation = None
                    time.sleep(1.5)
                    st.rerun()
                else:
                    st.error("Please enter a strategy name")
        
        with col3:
            if st.button("🚀 Save & Run Screener", use_container_width=True):
                if strategy_name_input:
                    # Save first
                    save_strategy = st.session_state.ai_generated_strategy.copy()
                    save_strategy['name'] = strategy_name_input
                    
                    filename = "".join(c for c in strategy_name_input if c.isalnum() or c in ' _').rstrip().lower().replace(" ", "_")
                    filepath = os.path.join(STRATEGIES_DIR, f"{filename}.json")
                    
                    with open(filepath, 'w') as f:
                        json.dump(save_strategy, f, indent=2)
                    
                    st.success(f"✅ Strategy saved! Reload the app and select it to run the screener.")
                    st.session_state.ai_generated_strategy = None
                    st.session_state.ai_explanation = None
                    time.sleep(1.5)
                    st.rerun()
                else:
                    st.error("Please enter a strategy name")


# ==============================================================================
# MAIN APP LAYOUT
# ==============================================================================
def main():
    st.set_page_config(
        page_title="Indian Stock Market Screener",
        page_icon="📈",
        layout="wide"
    )

    try:
        global ta
        import ta
    except ImportError:
        st.error("Required package 'ta' not found. Please install it: `pip install ta`")
        st.stop()
        
    create_directories()

    st.title("📈 Indian Stock Market Screener")
    st.caption("A powerful tool to screen Indian stocks using complex technical indicators and multiple timeframes.")
    
    screener = StockScreener()
    
    with st.sidebar:
        st.title("Screener Controls")
        
        strategy_names = list(screener.strategies.keys())
        if strategy_names:
            # Sort strategy names for better readability
            sorted_strategy_names = sorted(strategy_names, key=lambda x: screener.strategies[x].get('name', x))
            selected_strategy = st.selectbox(
                "Select Strategy",
                sorted_strategy_names,
                format_func=lambda x: screener.strategies[x].get('name', x)
            )
        else:
            selected_strategy = None
            st.warning("No strategies found. Create one in the Strategy Editor.")

        total_stocks_available = len(screener.stocks_df)
        max_stocks = st.slider("Max Stocks to Screen", 50, total_stocks_available, 200, 50,
                               help=f"Number of stocks to process from the top of the list ({total_stocks_available} total).")
        
        st.markdown(f"<div style='background-color:#0f1116; padding:10px; border-radius:10px; text-align:center;'>Total NSE Stocks Available: <b>{total_stocks_available}</b></div>", unsafe_allow_html=True)
        
        st.subheader("Price Filter")
        price_min, price_max = st.select_slider(
            "Price Range (₹)",
            options=[0, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000],
            value=(20, 2000)
        )
        st.write(f"Price between ₹{price_min} and ₹{price_max}")

        run_screener = st.button("🚀 Run Screener", type="primary", use_container_width=True)
    
    tab1, tab2, tab3 = st.tabs(["📊 Screener Results", "⚙️ Strategy Editor", "🤖 AI Strategy Builder"])
    
    def display_strategy_conditions(strategy_data):
        conditions = strategy_data.get('conditions', [])
        if not conditions:
            st.write("No conditions defined for this strategy.")
            return

        for i, cond in enumerate(conditions, 1):
            if 'lhs' in cond and 'rhs' in cond:
                st.markdown(f"**{i}.** {format_condition_as_html(cond)}", unsafe_allow_html=True)
            else:
                st.error(f"**{i}.** Unrecognized or outdated condition format found. Please recreate this strategy. `{cond}`")
                
    with tab1:
        if selected_strategy:
            strategy_info = screener.strategies[selected_strategy]
            st.subheader(f"Strategy: {strategy_info.get('name', selected_strategy)}")
            st.caption(strategy_info.get('description', 'No description available'))
            
            with st.expander("View Strategy Conditions"):
                display_strategy_conditions(strategy_info)
        
        if run_screener and selected_strategy:
            st.subheader("Screening Results")
            results = screener.screen_stocks(selected_strategy, max_stocks, price_min, price_max)
            
            if results:
                results_df = pd.DataFrame(results)
                
                st.download_button(
                    label="📥 Download Results as CSV",
                    data=results_df.to_csv(index=False).encode('utf-8'),
                    file_name=f"screener_results_{selected_strategy}.csv",
                    mime="text/csv"
                )
                
                # --- START OF CHANGE ---
                st.dataframe(results_df, use_container_width=True, hide_index=True,
                    column_config={
                        "TradingView": st.column_config.LinkColumn("Chart Link"),
                        "Price": st.column_config.NumberColumn("Price (₹)", format="%.2f"),
                        "%Chg": st.column_config.NumberColumn("% Change", format="%.2f%%"),
                        "Volume": st.column_config.NumberColumn(format="%d")
                    }
                )
                # --- END OF CHANGE ---
            else:
                st.warning("⚠️ No stocks found matching the selected criteria.")
        elif run_screener:
             st.error("Please select a strategy from the sidebar first.")
    
    with tab2:
        create_strategy_editor()
        st.markdown("---")
        st.subheader("📚 Existing Strategies")
        if not screener.strategies:
            st.info("You haven't saved any strategies yet.")
        else:
            for strategy_key, strategy_data in screener.strategies.items():
                with st.expander(f"**{strategy_data.get('name', strategy_key)}**"):
                    st.caption(strategy_data.get('description', 'No description'))
                    display_strategy_conditions(strategy_data)
                    
                    if st.button("🗑️ Delete Strategy", key=f"delete_{strategy_key}", type="secondary"):
                        filepath = os.path.join(STRATEGIES_DIR, f"{strategy_key}.json")
                        if os.path.exists(filepath):
                            os.remove(filepath)
                            st.success(f"Strategy '{strategy_data.get('name')}' deleted.")
                            time.sleep(1)
                            st.rerun()
    
    with tab3:
        create_ai_strategy_builder(screener)

if __name__ == "__main__":
    main()